\documentclass[parskip=full,11pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[useregional]{datetime2}
\usepackage[pdfborderstyle={/S/U/W 0}]{hyperref}
\usepackage[nameinlink]{cleveref}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{csquotes}
\usepackage{amsmath} % for $\text{}$
\usepackage{entwurf}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{bera}

\setlist{nosep}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}{\text{#2}}$}
\raggedbottom
\crefname{figure}{Abb}{Abb}

\newcommand\producttitle{treff.}
\hypersetup{
	pdftitle={Entwurf: \producttitle},
	bookmarks=true,
}


\graphicspath{ {images/} }

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}
\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\lstdefinelanguage{norm}{
    basicstyle=\normalfont\ttfamily,
    escapeinside={(*}{*)},
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
    language=Python,
    basicstyle=\normalfont\ttfamily,
    otherkeywords={self},
    keywordstyle=\ttb\color{deepblue},
    emph={normalize},
    emphstyle=\ttb\color{deepred},
    stringstyle=\color{deepgreen},
    frame=tb,
    showstringspaces=false,
    backgroundcolor=\color{background},
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    escapeinside={(*}{*)},
}}


% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% header & footer
\usepackage{scrlayer-scrpage}
%\lofoot{\today}
%\refoot{\today}
\pagestyle{scrheadings}

\title{\includegraphics[width = 80mm]{images/logo_crop.png}}
\subtitle{\huge Entwurf}
\author{Lukas Dippon
        \and Jens Kienle
        \and Matthias Noll
        \and Fabian Röpke
        \and Tim Schmidt
        \and Simon Vögele}

\begin{document}

\maketitle
\thispagestyle{empty} % removed page number from title

\pagebreak
\tableofcontents

%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Einleitung}

\subsection{Client-Server-Architektur}
Für die App \enquote{treff.} soll eine Klient-Server-Architektur verwendet
werden, um die Interaktion mehrerer Nutzer zu realisieren.
Hierbei stellen die Geräte der Nutzer die Klienten dar und der Server
fungiert als Vermittler und Datenbank.
Hierbei werden leicht bedienbare Kommunikationsschnittstellen verwendet.
Dadurch wird ebenfalls eine starke Kopplung zwischen den in diesem Dokument
vorgestellten Implementierungen für Klient und Server vermieden.
Außerdem ermöglicht dies Kompatibilität mit alternativen Implementierungen
von sowohl Klienten als auch Servern.

\subsection{Funktion - Client}
Der Klient speichert für den Nutzer relevante Daten in einer lokalen Datenbank
ab.
Diese können vom Nutzer eingesehen werden.
Anfragen des Nutzers werden in Form von Befehlen an den Server weitergegeben
(\ref{sec:commands}).
Diverse Daten wie beispielsweise GPS-Standort oder Chatnachrichten werden
dabei als Parameter der Befehle an den Server übergeben.

\subsection{Funktion - Server}
Der Server speichert die Daten der Nutzer in einer zentralen Datenbank, nimmt
Befehle der Klienten entgegen und verändert gegebenenfalls die Datensätze.
Bei Veränderung von Daten werden alle betroffenen Klienten darüber informiert,
welche daraufhin ihre lokalen Datensätze aktualisieren können.

\subsection{Sprache dieses Dokumentes}
Während dieses Entwurfsdokument grundsätzlich in deutscher Sprache verfasst
ist, besitzen die in der Implementierung erscheinenden Entitäten, Relationen,
Klassen, Funktionen etc. englische Namen.
Diese Namen sind ebenfalls in Diagrammen und Schnittstellenspezifikationen
zu finden.
Zur besseren Zuordnung sind die hier verwendeten Übersetzungen im Folgenden
aufgeführt.

\begin{tabular}[t]{ l l }
    \textbf{Deutsch} & \textbf{Englisch}\\
    \hline
    Benutzerkonto & account\\
    Gruppe & usergroup\\
		Gruppenmitgliedschaft & groupmembership\\
		Abstimmung & poll\\
		Abstimmungsoption & polloption\\
		Verabredung & event\\


\end{tabular}

%%%%%%%%%%%%%%%%%%%%
\pagebreak

\section{Semantisches Datenmodell}
Dieses Kapitel beschreibt den theoretischen Aufbau des in diesem Projekt
relevanten Ausschnitts der realen Welt.

\subsection{Benutzerkonto}
Ein Nutzer wird im System in Form eines Benutzerkontos repräsentiert.
Dieses wird durch eine eindeutige Identifikationsnummer 'id' identifiziert und
angesprochen. Jedes Benutzerkonto beinhaltet den Nutzernamen 'username' und
die verwendete E-Mailadresse 'email' des zugehörigen Nutzers.
Für das Benutzerkonto wird desweiteren der Hash seines Passworts und des Salts,
sowie das verwendete Salt gespeichert.
Außerdem wird durch die Werte 'lon' und 'lat' Längen- und Breitengrad der
aktuellen Position des Nutzers und durch 'timemeasured' der letzte
Messzeitpunkt dieser Position gespeichert.
Ein Benutzerkonto beinhaltet eine beliebig große Menge von Benutzerkonten,
den Kontakten/Freunden des Nutzers. Diese Menge darf leer sein, jedoch nicht
das eigene Benutzerkonto beinhalten.
Ein Benutzerkonto beinhaltet eine weitere,
beliebig große Menge von Benutzerkonten.
Diese Menge stellt die vom Nutzer blockierten Benutzerkonten dar und darf leer
sein, jedoch nicht das eigene Benutzerkonto beinhalten. Ein Benutzerkonto kann
Verabredungen erstellen und an solchen teilnehmen.
Ein Benutzerkonto kann Abstimmungen innerhalb einer Gruppe erstellen und für
deren Optionen abstimmen.
Jedes Benutzerkonto besitzt eine Gruppenmitgliedschaft für jede Gruppe, in der
es mitglied ist.
%TODO Warum haben wir was wie gemacht

\svgFigure{erd-account}{Benutzerkonto}{300pt}

\subsection{Gruppenmitgliedschaft}
Eine Gruppenmitgliedschaft gehört zu exakt einem Benutzerkonto und zu exakt
einer Gruppe. Sie wird durch eine eindeutige Identifikationsnummer 'id'
identifiziert und angesprochen. Außerdem beinhaltet sie boolsche Werte,
die angeben, welche Rechte das zugehörige Benutzerkonto in der zugehörigen
Gruppe hat. Diese Rechte beziehen sich dabei immer auf die zugehörige Gruppe
der Gruppenmitgliedschaft und sind nur in dieser gültig.\\
\begin{tabular}[t]{ l l }
    \textbf{Berechtigung} & \textbf{Berechtigt dazu}\\
    \hline
    permission-change-group-name & den Namen der Gruppe zu ändern.\\
    permission-manage-members & Nutzer bzw deren Benutzerkonto in die Gruppe\\
     & hinzuzufügen und Gruppenmitglieder zu entfernen.\\
    permission-change-permissions & die Gruppenberechtigungen der
        Gruppenmitglieder zu\\
     & bearbeiten.\\
    perm ission-create-event & Verabredungen zu erstellen.\\
    permission-edit-any-event & Verabredungen zu bearbeiten, welche man nicht
        selbst\\
     & erstellt hat.\\
    permission-create-poll & Abstimmungen zu erstellen.\\
    permission-edit-any-poll & Abstimmungen zu bearbeiten, welche man nicht
    selbst\\
     & erstellt hat.\\
\end{tabular}

%TODO Warum haben wir was wie gemacht
Diese Abbildung der Gruppenmitgliedschaften wurde gewählt um eine
Dreiecksbeziehung zwischen Benutzerkonto,
Gruppe und den Berechtigungen aufzulösen.

\svgFigure{erd-groupmembership}{Gruppenmitgliedschaft}{300pt}

\subsection{Gruppe}
Eine Gruppe ist eine Ansammlung von Nutzern. Sie wird durch eine eindeutige
Identifikationsnummer 'id' identifiziert und angesprochen. Eine Gruppe besitzt
einen Namen 'name' und beinhaltet eine beliebig große Menge der
Gruppenmitgliedschaften aller Nutzer, die Teil der Gruppe sind.
Da eine Gruppe ohne Mitglieder nicht existieren kann, darf diese Menge nicht
leer sein. Außerdem beinhaltet eine Gruppe eine beliebig große Menge an
Verabredungen und eine beliebig große Menge von Abstimmungen.
Da zu gewissen Zeitpunkten keine Verabredungen vereinbart oder in Planung sein
können, dürfen beide Mengen leer sein.
%TODO Warum haben wir was wie gemacht

\svgFigure{erd-group}{Gruppe}{200pt}

\subsection{Abstimmung}
Eine Abstimmung wird durch eine eindeutige Identifikationsnummer 'id'
identifiziert und angesprochen.
Eine Abstimmung besteht aus einer Frage, die für diese Abstimmung gestellt wird
und einem Wahrheitswert der festlegt,
ob die Abstimmung dem Nutzer erlaubt für mehrere oder nur für eine Option zu
stimmen.
Außerdem beinhaltet sie eine beliebig große Menge von Optionen der Abstimmung,
jedoch mindestens eine.
Desweiteren speichert die Abstimmung ein Benutzerkonto, ihren Ersteller.
%TODO Warum haben wir was wie gemacht

\svgFigure{erd-poll}{Abstimmung}{280pt}

\subsection{Abstimmungsoption}
Die Abstimmungsoption wird durch eine eindeutige Identifikationsnummer 'id'
identifiziert und angesprochen.
Die Option speichert ihren Start- und Endzeitpunkt starttime und endtime,
sowie ihre Position in Form der Werte 'lon' und 'lat' als Längen- und
Breitengrad.
Weiterhin wird eine beliebige Menge von Nutzern bzw deren Benutzerkonten
gespeichert, die für diese Option gestimmt haben.
%TODO Warum haben wir was wie gemacht

\svgFigure{erd-polloption}{Abstimmungsoption}{300pt}

\subsection{Verabredung}
Eine Verabredung wird durch eine eindeutige Identifikationsnummer 'id'
identifiziert und angesprochen. Sie besteht aus einem Namen 'title', einem
Start- sowie einem Endzeitpunkt 'timestart' und 'timeend',
und Längen- sowie Breitengrad des Treffpuktes 'lon' und 'lat'. Sie speichert
ihren Ersteller und die Gruppe, in der sie erstellt wurde.
Eine Verabredung beinhaltet eine beliebig große Teilmenge von Mitgliedern der
zugehörigen Gruppe.
Diese Menge stellt die Teilnehmer der Verabredung dar und darf auch leer sein.
%TODO Warum haben wir was wie gemacht

\svgFigure{erd-event}{Verabredung}{350pt}

\subsection{Gesammtkonstrukt}
\begin{figure}
    \centering
    \def\svgwidth{600pt}
    \rotatebox{90}{\input{build/images/erd-complete.pdf_tex}}
    \caption{Gesamtkonstrukt}
    \label{fig:erd-complete}
\end{figure}

\section{Aufbau und internes Verhalten - Client}

\subsection{Aufbau}
% Aufteilung in GUI und Datenverarbeitung (Fließtext)
% Ihre Funktionen
Der Client, also die App selbst, besteht grundsätzlich auch zwei Teilen:
der GUI, also dem für den Benutzer sichtbaren Teil und der im Hintergrund
ablaufenden Datenverwaltung.
Die GUI bietet dem Nutzer eine Oberfläche, mit der er einfach auf alle
Funktionen der App zugreifen kann.
Dabei ist es wichtig, die beiden Teile klar voneinander zu entkoppeln,
um z.B. Datenverlust und inkonsistentes Verhalten zu verhindern, das sonst
bei Aktionen wie dem Pausieren oder drehen der App vorkommen kann.

\subsubsection{MVVM}
Um diese Entkopplung zu erreichen kommt die MVVM-Architektur
(Model-View-ViewModel) zum Einsatz.
Das bedeutet, dass der Client in 3 wesentliche Schichten gegliedert ist:
\begin{itemize}
	\item Die View-Ebene (meistens gegeben durch Activities oder Fragments)
        behandeln Eingaben des Nutzers und bestimmen das Aussehen der
        Benutzeroberfläche.
	\item Das Model stellt eine Abstraktion der zugrunde liegenden
        Datenstruktur zur Verfügung. In diesem Fall handelt es sich dabei um
        Repositories, welche sowohl auf eine lokale Datenbank zugreifen können,
        als auch über einen Netzwerkadapter Updates vom Server anfordern
        können.
	\item Die Verbindung zwischen der Model- und der View-Ebene stellen
        ViewModels dar. Diese stellen der darüber liegenden View Verbindungen
        zu allen benötigten Daten zur Verfügung.
	    Wichtig ist dieser Schritt deshalb, weil ViewModels im Gegensatz zu
        View-Objekten auch Configuration-changes überleben, die Daten also z.B.
        nach dem Drehen des Geräts weiterhin zur Verfügung stehen und sofort
        wieder von der View verwendet werden können.
\end{itemize}

\begin{center}
	\svgFigure{database}{Bei dieser Darstellung sind View und ViewModel nicht
        als tatsächliche packages zu verstehen, sondern dienen lediglich der
        vereinfachten Darstellung. Ebenso wenig ist dieses Diagramm
        vollständig.
        Fehlende Klassen verhalten sich allerdings äquivalent.}{200pt}
\end{center}

\subsubsection{LiveData}
Um sicherzustellen, dass die View stets mit dem Model synchronisiert ist,
bietet Android eine WrapperKlasse namens LiveData an, welche von View-Elementen
\enquote{observed} werden kann. Wenn sich nun durch eine Änderung der Datenbank
die anzuzeigenden Daten verändern, werden alle Observer (also die View) darüber
benachrichtigt und können entsprechend angepasst werden.
Room ermöglicht es, dass aus der SQL-Datenbank LiveData Objekte generiert
werden und stellt sicher, dass diese bei Änderungen der Datenbank auch die
nötigen onChange() Methoden aufrufen. Der Ablauf eines solchen Updates lässt
sich in Abb.\ref{fig:datafetch} nachvollziehen.

	\begin{figure}
		\def\svgwidth{250pt}
		\rotatebox{90}{\input{build/images/datafetch.pdf_tex}}
		\caption{Dieser Ablauf steht beispielhaft für fast alle Zugriffe auf
            die Datenbank. Im oberen Teil ist zu sehen, wie ein View-Objekt
            (in diesem Fall fragment) sich als Observer eines LiveData Objekts
            eintragen kann. Im unteren Teil ist zu sehen, wie dieses auf eine
            Änderung reagiert und das fragment benachrichtigt.}
		\label{fig:datafetch}
	\end{figure}

%

\subsection{Bestandteile der GUI}
% Strukturierung der GUI durch Activities und deren Aufteilung in Fragments,
%	sowie das Zusammenspiel der Activities (Fließtext und UML-Klassendiagramme,
% ggf Sequenzdiagramme)

Die GUI besteht im Wesentlichen aus den folgenden vier Teilen. Den
wahrscheinlich wichtigsten Teil stellt die Home-Activity dar, auf dem der
Nutzer in vier Tabs auf alle Gruppen, Events, Freunde und die Karte zugreifen
kann. Details zu einer Gruppe, sowie alle in dieser Gruppe geplanten Events
können in einer eigenen Activity eingesehen werden. Außerdem wird eine Activity
benötigt, die es dem Nutzer erlaubt, sich einzuloggen bzw. zu registrieren.
Die letzte wichtige Komponente stellt die Settings-Activity dar, in welcher
der Nutzer Benutzerkonto-Einstellungen vornehmen kann.

\subsubsection{Home-Activity}
Diese Activity stellt den wichtigsten Teil der Anwendung dar, da der Nutzer
nach dem Login hier landet und auf alle weiteren Funktionen von hier aus
zugreifen kann. Die unterschiedlichen Tabs mit Karte, Freundes-, Gruppen-, und
Eventliste werden dabei als Fragments realisiert, welche von einem
ViewPagerAdapter verwaltet werden. Bis auf das Mapfragment unterscheiden sich
die Fragments selbst kaum voneinander, da alle anderen lediglich eine Liste
darstellen müssen. Um dies zu bewerkstelligen kommt eine Recyclerview zum
Einsatz, da sie flexibler und weniger ressourcenbelastend ist als zuvor
übliche Listviews. Jede dieser Recyclerviews besteht im wesentlichen aus
drei Teilen:
\begin{itemize}
	\item{ViewHolder} ist dafür verantwortlich, die Daten eines einzelnen
        Elements der Liste zu behalten und die Verbindung zum Layout eines
        Listeneintrags herzustellen.
	\item{Adapter} stellt die Verbindung zwischen der Menge an Daten, die
        angezeigt werden soll und den ViewHoldern dar.
	\item{Layoutmanager} bestimmt, wie die einzelnen Elemente der Liste
        zueinander angeordnet sein sollen
        (Im Falle einer Liste also ein LinearLayoutManager).
\end{itemize}
Für den LayoutManager existiert bereits eine fertige Implementierung, der
LinearLayoutManager, welcher die items als Liste darstellt. Sowohl der
ViewHolder als auch der Adapter wird jedoch für den entsprechenden
Verwendungszweck von uns erweitert, wie in Abb.\ref{fig:lists} zu erkennen ist.

\begin{center}
	\svgFigure{lists}{Diese Darstellung zeigt die Vererbungen und Beziehungen
    im Aufbau einer RecyclerView am Beispiel der FriendList. Group- und
    EventList verhalten sich allerdings äquivalent.}{200pt}
\end{center}


\subsection{Bestandteile Datenverarbeitung}
% Aufteilung der Funktionalitäten auf seperate Klassen,
% sowie deren Zusammenspiel (Fließtext und UML-Klassendiagramme,
% ggf Sequenzdiagramme)

\subsection{Kommunikation von GUI und Datenverarbeitung}
% Zusammenspiel von GUI und Datenverarbeitung
% (Fließtext und UML-Klassendiagramme, ggf Sequenzdiagramme)

\subsection{JavaDoc}

%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Aufbau und internes Verhalten - Server}

\subsection{Aufbau}
% Aufteilung der Funktionalitäten auf seperate Klassen;
% Zusammenspiel dieser Klassen (Fließtext und UML-Klassendiagramme,
% ggf Sequenzdiagramme)
Der Server besteht aus drei verschiedenen Bestandteilen:

\subsubsection{Netzwerkkommunikation}
%Klassendiagramm(Server, ConnectionHandler und Kontext)
Die Klasse 'Server' ist die Hauptklasse des Servers.
Sie startet beim Hochfahren des Servers die Datenbank und ist zuständig für
die Netzwerkkommunikation. Dazu wird für jede Verbindung die der Server mit
Klienten hat ein ConnectionHandler erstellt. Diese geben die erhaltenen
Anfragen an den RequestHandler weiter und senden am Ende die erhaltenen
Antworten zurück an den Klienten.

\subsubsection{De- und Encodierung von Anfragen}
%Klassendiagramm RequestHandler und Kontext
Die Klasse RequestHandler erhält die Kodierten Anfragen an die Datenbank und
ist für die Dekodierung und Weiterleitung der Anfragen zuständig, sowie für
für die Kodierung der Antworten und die Rückgabe der Antworten an die
ConnectionHandler.

\subsubsection{Datenbankzugriff}
%Klassendiagramm sql-package
Die Klasse EntityManager ist für den Datenbankzugriff verantwortlich.
Dazu werden die Anfragen vom RequestHandler entgegengenommen auf der Datenbank
ausgeführt und die Ergebnisse zum Encodieren an den RequestHandler
zurückgegeben.

\subsection{Bestandteile des Servers}
% Aufbau und genaue Funktionalität dieser Klassen
% [z.B. Datenbank, Schnittstelle zum Client]
% (Fließtext und UML-Klassendiagramme, ggf Sequenzdiagramme)

\subsection{JavaDoc}

%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Kommunikation zwischen Client und Server}
% Zusammenspiel von Client und Server
% (Fließtext und Sequenzdiagram, ggf UML-Klassendiagram)
% TODO: JSON verlinken / footnote
% TODO: Alphabet und Escapes genau festlegen
Client und Server kommunizieren mittels Nachrichten im JSON-Format.
Die oberste Ebene jeder Nachricht bildet ein einzelnes JSON-Objekt.
Parameter, Rückgabewerte und Fehlercodes werden als Eigenschaften dieses
Objektes kodiert.
Eine Anfrage beinhaltet immer mindestens eine Eigenschaft mit dem Schlüssel
\textbf{cmd}.
Die Namen der im folgenden definierten Befehle sind exakt die Werte, die bei
Kodierung als Nachricht den Wert der \textbf{cmd}-Eigenschaft bilden müssen.
Diese Namen sind als Zeichenketten zu kodieren.
\\Wird während der Ausführung des Befehls ein Fehler gefunden, möglicherweise
durch übermittelte Parameter bedingt, wird nur ein Fehlercode mit dem Schlüssel
\textbf{error} zurückgegeben. Die Bedeutung der Fehlercodes wird ebenfalls im
folgenden definiert.

\subsection{Befehle}\label{sec:commands}

\apiErrorNew{username-already-in-use}{000}{Nutzername schon vergeben}
\apiErrorNew{invalid-email}{010}{Email nicht gültig}
\apiErrorNew{token-invalid}{020}{Authentifizierungstoken ungültig}
\apiErrorNew{cred-wrong}{030}{Nutzername/Passwort-Kombination ungültig}

\apiErrorNew{no-permission-group-edit}{100}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um die Gruppe zu editieren}
\apiErrorNew{no-permission-members-edit}{101}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um die Liste an Gruppenmitgliedern zu editieren}
\apiErrorNew{no-permission-event-create}{110}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um in der angegebenen Gruppe Verabredungen zu erstellen}
\apiErrorNew{no-permission-event-edit}{111}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um die Verabredung zu editieren}
\apiErrorNew{no-permission-poll-create}{120}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um in der angegebenen Gruppe Abstimmung zu erstellen}
\apiErrorNew{no-permission-poll-edit}{121}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um die Abstimmung zu editieren}
\apiErrorNew{no-permission-permissions-edit}{122}{Das Benutzerkonto besitzt
nicht die nötigen Rechte, um die Berechtigungen zu editieren}

\apiErrorNew{username-invalid}{200}{Nutzername ungültig}
\apiErrorNew{user-id-invalid}{201}{Mindestens eine
Benutzerkonto-Identifikationsnummer ungültig}
\apiErrorNew{group-id-invalid}{210}{Gruppen-Identifikationsnummer ungültig
oder Benutzerkonto nicht Teil der Gruppe}
\apiErrorNew{event-id-invalid}{220}{Verabredungs-Identifikationsnummer ungültig}
\apiErrorNew{poll-id-invalid}{230}{Abstimmungs-Identifikationsnummer ungültig}

\apiErrorNew{time-end-in-past}{300}{Mindestens ein Endzeitpunkt liegt
in der Vergangenheit}
\apiErrorNew{time-end-start-conflict}{301}{Mindestens ein Endzeitpunkt liegt
nicht nach dem dazugehörigen Startzeitpunkt}
\apiErrorNew{time-measured-future}{310}{Messzeitpunkt liegt zu weit in der
Zukunft}

\apiErrorNew{no-user-invited}{400}{Kein Benutzerkonto eingeladen,
das nicht das eigene ist}
\apiErrorNew{user-already-in-group}{401}{Mindestens eine Identifikationsnummer
gehört zu einem Benutzerkonto, welches bereits Teil der Gruppe ist}
\apiErrorNew{user-not-in-group}{402}{Mindestens eine Identifikationsnummer
gehört zu einem Benutzerkonto, welches nicht Teil der Gruppe ist}

\apiErrorNew{not-in-contacts}{500}{Benutzerkonto nicht in
der eigenen Kontaktliste}
\apiErrorNew{being-blocked}{501}{Benutzerkonto wird vom angegeben
Benutzerkonto blockiert}
\apiErrorNew{blocking-already}{510}{Benutzerkonto wird durch
das eigene Benutzerkonto blockiert}
\apiErrorNew{not-blocking}{511}{Benutzerkonto wird nicht durch
das eigene Benutzerkonto blockiert}

Bis auf dem \textbf{login}-Befehl und den \textbf{register}-Befehl erfordert
jeder Befehl folgenden Parameter:\\
\apiArgument{token/Authentifizierungtoken{,} welches beim Einloggen in das
Benutzerkonto vom Server zurückgegeben wurde}
\par\par Ist das übermittelte Token ungültig, wird der Befehl nicht
ausgeführt und folgender Fehlercode zurückgegeben:\\
\apiErrorPrint{token-invalid}

\apiCommand{register}
{Registrieren eines Nutzerkontos}
{user/Benutzername des Kontos,
pass/Passwort des Kontos,
email/Email des Kontos}
{token/Authentifizierungstoken{,} welches in weiteren Befehlen
als Eingabe verlangt wird}
{username-already-in-use,invalid-email}

\apiCommand{login}
{Einloggen in ein Nutzerkonto}
{user/Benutzername des Kontos,
pass/Passwort des Kontos}
{token/Authentifizierungstoken{,} welches in weiteren Befehlen
als Eingabe verlangt wird}
{cred-wrong}

\apiCommand{edit-username}
{Editieren des eigenen Benutzernamens}
{id/Identifikationsnummer des eigenen Benutzerkontos,
pass/Passwort des eigenen Kontos,
name/vorgeschlagener{,} neuer Name}
{---/Leeres JSON-Objekt bei Erfolg}
{cred-wrong, user-id-invalid, invalid-email}

\apiCommand{edit-email}
{Editieren der eigenen E-Mail-Adresse}
{id/Identifikationsnummer des eigenen Benutzerkontos,
pass/Passwort des eigenen Kontos,
email/vorgeschlagene{,} neue E-Mail}
{---/Leeres JSON-Objekt bei Erfolg}
{cred-wrong, user-id-invalid, username-already-in-use}\

\apiCommand{edit-password}
{Editieren des eigenen Passworts}
{id/Identifikationsnummer des eigenen Benutzerkontos,
pass/aktuelles Passwort des eigenen Kontos,
newpass/vorgeschlagenes{,} neues Passwort}
{---/Leeres JSON-Objekt bei Erfolg}
{cred-wrong, user-id-invalid}

\apiCommand{reset-password}
{Zurücksetzen des eigenen Passworts. Dies führt dazu, dass das eigene Passwort
vom Server durch ein von diesem generierten ersetzt wird. Anschließend wird das
neue Passwort an an die angegebene E-Mail-Adresse des Kontos verschickt.}
%TODO wirklich ersetzt oder ist das alte ebenfalls nach wie vor gültig
{id/Identifikationsnummer des eigenen Benutzerkontos,
pass/Passwort des eigenen Kontos}
{---/Leeres JSON-Objekt bei Erfolg}
{cred-wrong, user-id-invalid}

\apiCommand{delete-account}
{Löschen des eigenen Kontos .Dies führt wie erwartet dazu{,}
dass der Nutzer automatisch ausgeloggt wird und dadurch seinen
Authentifizierungstoken und somit den weiteren Zugriff auf die Funktionalitäten
der App verliert.}
{id/Identifikationsnummer des eigenen Benutzerkontos,
pass/Passwort des eigenen Kontos}
{---/Leeres JSON-Objekt bei Erfolg}
{cred-wrong, user-id-invalid}

\apiCommand{get-user-id}
{Abrufen der Idenfikationsnummer eines anderen Benutzekontos durch Übergeben
des Benutzernamens}
{user/Benutzername des Benutzerkontos}
{\dots/Eine Beschreibung eines Benutzerkontos{,} das zu dem angegebenen
Benutzernamen gehört (siehe \ref{sec:accountdesc})}
{username-invalid}

\apiCommand{add-contact}
{Hinzufügen eines anderen Benutzerkontos zur eigenen Kontaktliste.
Fügt ebenfalls das eigene Benutzerkonto zur Kontaktliste des anderen
Benutzerkontos hinzu.
Dies schlägt fehl, wenn eines der zwei Benutzerkonten das andere blockiert.}
{id/Identifikationsnummer des anderen Benutzerkontos}
{---/Leeres JSON-Objekt bei Erfolg}
{user-id-invalid,being-blocked,blocking-already}

\apiCommand{remove-contact}
{Entfernen eines anderen Benutzerkontos von der eigenen Kontaktliste.
Entfernt ebenfalls das eigene Benutzerkonto von der Kontaktliste des anderen.}
{id/Identifikationsnummer des anderen Benutzerkontos}
{---/Leeres JSON-Objekt bei Erfolg}
{user-id-invalid,not-in-contacts}

\apiCommand{list-contacts}
{Auflisten aller Kontakte des Benutzerkonto}
{---/Keine weiteren Parameter}
{contacts/Ein Array von Indetifikationsnummern anderer Benutzerkonten}
{user-id-invalid}

\apiCommand{block-account}
{Blockiert das angegebene Benutzerkonto.
Bis dies aufgehoben wird, können das eigene und das angegebene
Benutzerkonto sich nicht gegenseitig zur ihrer Kontaktliste hinzufügen.
Sind die beiden Benutzerkonten bereits Kontakte, werden diese vorher aus der
Kontaktliste des jeweils anderen Benutzerkontos entfernt.}
{id/Identifikationsnummer des anderen Benutzerkontos}
{---/Leeres JSON-Objekt bei Erfolg}
{user-id-invalid,blocking-already}

\apiCommand{unblock-account}
{Hebt die Blockierung des angegebenen Benutzerkontos durch das eigene
Benutzerkonto auf.}
{id/Identifikationsnummer des anderen Benutzerkontos}
{---/Leeres JSON-Objekt bei Erfolg}
{user-id-invalid,not-blocking}

\apiCommand{create-group}
{Erstellen einer Gruppe}
{name/Name der Gruppe,
members/Array an Identifikationsnummern aller Benutzerkonten{,} die nach
Erstellung der Gruppe dieser hinzugefügt werden sollen.
Die Identifikationsnummer des eigenen Benutzerkontos muss nicht angegeben
werden.
Falls dennoch vorhanden{,} wird diese ignoriert.
Das Array muss mindestens eine gültige Identifikationsnummer beinhalten{,} die
nicht die eigene ist.}
{id/Eindeutige Identifikationsnummer der Gruppe{,} mit der diese in
weiteren Befehlen referenziert werden kann}
{user-id-invalid,no-user-invited}

\apiCommand{edit-group-name}
{Editieren des Namens einer Gruppe, in der das Benutzerkonto Mitglied ist}
{id/Eindeutige Identifikationsnummer der Gruppe,
name/Neuer name der Gruppe}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,no-permission-group-edit}

\apiCommand{add-group-members}
{Hinzufügen eines oder mehrerer Benutzerkonten zu einer Gruppe, in der das
Benutzerkonto Mitglied ist}
{id/Eindeutige Identifikationsnummer der Gruppe,
members/Array an Identifikationsnummern aller Benutzerkonten{,} die der Gruppe
hinzugefügt werden sollen.
Es dürfen keine Identifikationsnummern von Benutzerkonten angegeben werden{,}
die bereits Teil der Gruppe ist.
Insbesondere darf nicht die Identifikationsnummer des eigenen Benutzerkontos
angegeben werden.}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,user-id-invalid,no-permission-members-edit,%
user-already-in-group}

\apiCommand{remove-group-members}
{Entfernen eines oder mehrerer Benutzerkonten von einer Gruppe, in der das
Benutzerkonto Mitglied ist}
{id/Eindeutige Identifikationsnummer der Gruppe,
members/Array an Identifikationsnummern aller Benutzerkonten{,} die aus der
Gruppe entfernt werden sollen.
Es dürfen keine Identifikationsnummern von Benutzerkonten angegeben werden{,}
die nicht Teil der Gruppe sind.
Es darf die Identifikationsnummer des eigenen Benutzerkontos angegeben werden.
Dies führt wie erwartet dazu{,} dass das eigene Benutzerkonto den weiteren
Zugriff auf die Gruppe verliert.
Werden durch diesen Befehl alle Mitglieder einer Gruppe entfernt{,} wird die
Gruppe gelöscht.}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,user-id-invalid,no-permission-members-edit,user-not-in-group}

\apiCommand{get-permissions}
{Abfragen der Rechte eines Benutzerkontos in einer Gruppe}
{id/Eindeutige Identifikationsnummer der Gruppe,
userid/Eindeutige Identifikationsnummer des Benutzerkontos}
{permissions/Ein Array an Booleans das die Berectigungen darstellt}
{group-id-invalid, no-permission-permissions-edit}

\apiCommand{set-permissions}
{Ändern der Rechte eines Benutzerkontos in einer Gruppe}
{id/Eindeutige Identifikationsnummer der Gruppe,
userid/Eindeutige Identifikationsnummer des Benutzerkontos,
permissions/Ein Array an Booleans das die Berectigungen darstellt}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid, no-permission-permissions-edit}

\apiCommand{create-event}
{Erstellen einer Verabredung in einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
werden soll,
title/Titel der Verabredung,
time-start/Startzeitpunkt (Angabe in Unixzeit%
\footnote{Siehe \enquote{Unixzeit}, Version 172239469, Wikipedia,\\
\url{https://de.wikipedia.org/w/index.php?title=Unixzeit&oldid=172239469}}),
time-end/Endzeitpunkt (Angabe in Unixzeit),
latitude/Breitengrad{,} auf dem die Verabredung stattfindet (Angabe als
Dezimalgrad),
longitude/Längengrad{,} auf dem die Verabredung stattfindet (Angabe als
Dezimalgrad)}
{id/Eindeutige Identifikationsnummer der Verabredung{,} mit der diese in
weiteren Befehlen referenziert werden kann}
{group-id-invalid,time-end-in-past,time-end-start-conflict,
no-permission-event-create}

\apiCommand{edit-event}
{Editieren einer Verabredung in einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde,
id/Identifikationsnummer der Verabredung,
\dots/Alle Eigenschaften{,} mit Ausnahme des Teilnehmerarrays und der
Identifikationsnummer{,} die überschrieben werden sollen.
Die Schlüssel entsprechen denen einer ausführlichen Verabredungsbeschreibung.}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,time-end-in-past,time-end-start-conflict,event-id-invalid,%
no-permission-event-edit}

\apiCommand{remove-event}
{Entfernen einer Verabredung aus einer Gruppe, in der das Benutzerkonto
Mitglied ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde,
id/Identifikationsnummer der Verabredung}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,event-id-invalid,no-permission-event-edit}

\apiCommand{create-poll}
{Erstellen einer Abstimmung in einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
werden soll,
question/Frage{,} über dessen Antwort abgestimmt wird,
multi-choice/Boolscher Wert{,} der angibt{,} ob ein Nutzer für mehrere
Optionen stimmen kann,
options/Array an Beschreibungen von Abstimmungsoptionen{,} die nach der
Erstellung der Abstimmung hinzugefügt werden sollen}
{id/Eindeutige Identifikationsnummer der Abstimmung{,} mit der diese in
weiteren Befehlen referenziert werden kann,
option-ids/Array an Identifikationsnummern der Abstimmungsoptionen. Die
Reihenfolge dieser IDs entspricht genau der Reihenfolge der angegebenen
Abstimmungsoptionen.}
{group-id-invalid,time-end-in-past,time-end-start-conflict,
no-permission-poll-create}

\apiCommand{edit-poll}
{Editieren einer Abstimmung in einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde,
id/Identifikationsnummer der Abstimmung,
\dots/Alle Eigenschaften{,} mit Ausnahme des Abstimmungsoptionsarrays und der
Identifikationsnummer{,} die überschrieben werden sollen.
Die Schlüssel entsprechen denen einer ausführlichen Abstimmungsbeschreibung.}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,poll-id-invalid,no-permission-poll-edit}

\apiCommand{add-poll-option}
{Hinzufügen einer Abstimmungsoption in einer Gruppe, in der das Benutzerkonto
Mitglied ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
wurde,
poll-id/Identifikationsnummer der Abstimmung{,} zu der die Abstimmungsoption
hinzugefügt werden soll,
latitude/Breitengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
longitude/Längengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
time-start/Vorgeschlagener Startzeitpunkt (Angabe in Unixzeit),
time-end/Vorgeschlagener Endzeitpunkt (Angabe in Unixzeit)}
{id/Eindeutige Identifikationsnummer der Abstimmungsoption{,} mit der diese in
weiteren Befehlen referenziert werden kann}
{group-id-invalid,poll-id-invalid,time-end-in-past,time-end-start-conflict,
no-permission-poll-edit}

% TODO: „Wählerarray“ besser formulieren
\apiCommand{edit-poll-option}
{Editieren einer Abstimmungsoption in einer Gruppe, in der das Benutzerkonto
Mitglied ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
wurde,
poll-id/Identifikationsnummer der Abstimmung,
id/Identifikationsnummer der Abstimmungsoption,
\dots/Alle Eigenschaften{,} mit Ausnahme des Wählerarrays und der
Identifikationsnummer{,} die überschrieben werden sollen.
Die Schlüssel entsprechen denen einer ausführlichen Abstimmungsbeschreibung.}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,poll-id-invalid,no-permission-poll-edit}

\apiCommand{remove-poll-option}
{Entfernen einer Abstimmungsoption in einer Gruppe, in der das Benutzerkonto
Mitglied ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
wurde,
poll-id/Identifikationsnummer der Abstimmung,
id/Identifikationsnummer der Abstimmungsoption}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,poll-id-invalid,no-permission-poll-edit}

\apiCommand{remove-poll}
{Entfernen einer Abstimmung aus einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde,
id/Identifikationsnummer der Abstimmung}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,poll-id-invalid,no-permission-poll-edit}

\apiCommand{send-chat-message}
{Senden einer Textnachricht an eine Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe,
message/Textnachricht} % TODO: Länge beschränken (vllt. auch Gruppengröße etc)
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid}

\apiCommand{list-groups}
{Auflisten der Gruppen, in denen das Benutzerkonto Mitglied ist}
{---/Keine weiteren Parameter}
{groups/Ein Array an oberflächlich beschriebenen Gruppen (siehe
Kapitel \ref{sec:groupdesc})}
{}

\apiCommand{get-group-details}
{Abrufen von Details einer Gruppe, in denen das Benutzerkonto Mitglied ist}
{id/Identifikationsnummer der Gruppe}
{\dots/Eine ausführliche Beschreibung der Gruppe{,} die zu der angegebenen
Identifikationsnummer gehört (siehe \ref{sec:groupdesc})}
{group-id-invalid}

% TODO: Definiere „aktive Verabredung“
\apiCommand{get-event-details}
{Abrufen von Details einer aktiven Verabredung, die in einer Gruppe erstellt
wurde, in der das Benutzerkonto Mitglied ist}
{id/Identifikationsnummer der Verabredung,
group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde}
{\dots/Eine ausführliche Beschreibung der Verabredung{,} die zu der angegebenen
Identifikationsnummer gehört (siehe \ref{sec:eventdesc})}
{group-id-invalid,event-id-invalid}

\apiCommand{get-poll-details}
{Abrufen von Details einer aktiven Abstimmung, die in einer Gruppe erstellt
wurde, in der das Benutzerkonto Mitglied ist}
{id/Identifikationsnummer der Abstimmung,
group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
wurde}
{\dots/Eine ausführliche Beschreibung der Abstimmung{,} die zu der angegebenen
Identifikationsnummer gehört (siehe \ref{sec:polldesc})}
{group-id-invalid,poll-id-invalid}

% TODO: Zeit-Toleranz / Annahmen über Synchronität weiter oben spezifizieren
\apiCommand{request-position}
{Sendet eine Standortanfrage an eine Gruppe}
{id/Eindeutige Identifikationsnummer der Gruppe,
time/ Endzeit der Standortübertragung}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid}

% TODO: Zeit-Toleranz / Annahmen über Synchronität weiter oben spezifizieren
\apiCommand{update-position}
{Aktualisiert die Position des Benutzerkontos.
Der Messzeitpunkt darf aus Sicht der Servers maximal 30 Sekunden in der Zukunft
liegen.}
{latitude/Breitengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
longitude/Längengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
time-measured/Zeitpunkt{,} zu dem die Position gemessen wurde (Angabe in
Unixzeit)}
{---/Leeres JSON-Objekt bei Erfolg}
{time-measured-future}

\subsection{Fehlercodes}\label{sec:errorcodes}
\apiErrorTable

\subsection{Gruppenbeschreibung}\label{sec:groupdesc}

\subsubsection{Oberflächlich}
\apiArgument{
    type/\enquote{group},
    id/Eindeutige Identifikationsnummer der Gruppe{,} mit der diese in
    weiteren Befehlen referenziert werden kann,
    checksum/Prüfsumme der ausführlichen Beschreibung (siehe
    \ref{sec:checksum})}

\subsubsection{Ausführlich}
\apiArgument{
    type/\enquote{group},
    id/Eindeutige Identifikationsnummer der Gruppe{,} mit der diese in
    weiteren Befehlen referenziert werden kann,
    name/Name der Gruppe,
    members/Array an Identifikationsnummern aller Benutzerkonten{,} die
    Mitglied der Gruppe sind,
    events/Array an oberflächlich beschriebenen Verabredungen{,} die in der
    Gruppe erstellt worden sind (siehe \ref{sec:eventdesc}),
    polls/Array an oberflächlich beschriebenen Abstimmungen{,} die in der
    Gruppe erstellt worden sind (siehe \ref{sec:polldesc})
}

\subsection{Benutzerkontobeschreibung}\label{sec:accountdesc}
\apiArgument{type/\enquote{account},
    id/Eindeutige Identifikationsnummer des Benutzerkontos{,} mit der
    dieses in weiteren Befehlen referenziert werden kann,
    user/Benutzername des Kontos
}

\subsection{Verabredungsbeschreibung}\label{sec:eventdesc}

\subsubsection{Oberflächlich}
\apiArgument{type/\enquote{event},
    id/Eindeutige Identifikationsnummer der Verabredung{,} mit der
    diese in weiteren Befehlen referenziert werden kann,
    checksum/Prüfsumme der ausführlichen Beschreibung (siehe
    \ref{sec:checksum})
}

\subsubsection{Ausführlich}
\apiArgument{type/\enquote{event},
    id/Eindeutige Identifikationsnummer der Verabredung{,} mit der
    diese in weiteren Befehlen referenziert werden kann,
    title/Titel der Verabredung,
    creator/Nutzername des Benutzerkontos{,} mit dem die Verabredung erstellt
    wurde,
    time-start/Startzeitpunkt,
    time-end/Endzeitpunkt,
    latitude/Breitengrad{,} auf dem die Verabredung stattfindet
    (Gleitkommazahl),
    longitude/Längengrad{,} auf dem die Verabredung stattfindet
    (Gleitkommazahl),
    participants/Array an Benutzernamen der Benutzerkonten{,} die an der
    Verabredung teilnehmen
}

\subsection{Abstimmungsbeschreibung}\label{sec:polldesc}
% TODO: Split in oberflächlich und ausführlich
\apiArgument{
    type/\enquote{poll},
    id/Eindeutige Identifikationsnummer der Abstimmung{,} mit der diese in
    weiteren Befehlen referenziert werden kann,
    question/Frage{,} über dessen Antwort abgestimmt wird,
    multi-choice/Boolscher Wert{,} der angibt{,} ob ein Nutzer für mehrere
    Optionen stimmen kann,
    options/Array an Beschreibungen von Abstimmungsoptionen{,} die Teil dieser
    Abstimmung sind
}

\subsection{Abstimmungsoptionsbeschreibung}\label{sec:polloptiondesc}
\apiArgument{
    type/\enquote{poll-option},
    id/Eindeutige Identifikationsnummer der Abstimmungsoption{,} mit der diese
    in weiteren Befehlen referenziert werden kann,
    latitude/Breitengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
    longitude/Längengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
    time-start/Vorgeschlagener Startzeitpunkt (Angabe in Unixzeit),
    time-end/Vorgeschlagener Endzeitpunkt (Angabe in Unixzeit),
    supporters/Array an Identifikationsnummern der Benutzerkonten{,} die
    momentan für diese Options stimmen.
}

\subsection{Prüfsummen für ausführliche Beschreibungen}\label{sec:checksum}
\newcommand{\hashAlg}{MD5}
Um unnötige ausführliche Übertragungen zu vermeiden beinhalten oberflächliche
Beschreibungen Prüfsummen der zum selben Objekt gehörenden ausführlichen
Beschreibung.
Der Client ist somit in der Lage, festzustellen, ob seine lokalen Datensätze
mit denen des Servers übereinstimmen, ohne die Datensätze erneut anfordern zu
müssen.

\par Zur Berechnung der Prüfsummen wird der \hashAlg-Algorithmus verwendet.

\par Da es mehrere unterschiedliche, aber äquivalente JSON-Darstellungen für
eine ausführliche Beschreibung gibt, müssen diese vor Eingabe an den
\hashAlg-Algorithmus in eine normalisierte Form gebracht werden.

\par \textit{Hinweis: In dem folgenden Absatz bezeichnen Ziffern nicht etwa die
ASCII-Ziffern \enquote{0} bis \enquote{9} mit den Werten 48 bis 57, sondern die
nicht darstellbaren Steuerzeichen mit den Werten 0 bis 9.}\\
JSON-Objekte werden mit einer 1 begonnen und mit einer 3 beendet.
Eigenschaften dieser JSON-Objekte werden mit einer 2 statt einem Komma
getrennt.
Die Eigenschaften werden gemäß der in den Beschreibungsspezifikationen
aufgeführten Reihenfolgen sortiert.
JSON-Arrays werden mit einer 4 begonnen und mit einer 6 beendet.
Elemente dieser JSON-Arrays werden mit einer 5 statt mit einem Komma getrennt.
In JSON-Arrays von Beschreibungen kommen lediglich Beschreibungen anderer
Objekte vor. Diese werden aufsteigend nach ihren IDs sortiert.

Alle JSON-Objekteigenschaften werden ohne Schlüssel, Doppelpunkte, geschwungene
Klammern und zusätzliche Leerzeichen oder Zeilenumbrüche konkateniert.
Alle JSON-Arrayelemente werden ohne eckige Klammern und zusätzliche
Leerzeichen oder Zeilenumbrüche konkateniert.
Die doppelten Anführungszeichen um Zeichenketten werden entfernt.
Da alle sechs Trennzeichen nur als Escape-Sequenzen, nicht aber direkt im
JSON-Format vorkommen können\footnote{Vgl. \enquote{RFC 7159}, Kapitel 7
\enquote{Strings}, \url{https://tools.ietf.org/html/rfc7159}} ist diese
Darstellung eindeutig.

% TODO: Update example
\par Im folgenden beispielhaft eine Verabredung mit folgenden Details:
\begin{itemize}
    \item Besitzt die ID 12
    \item Trägt den Titel \enquote{Beispielverabredung 1010}
    \item Erstellt vom Benutzerkonto mit ID 200
    \item Beginnt am 01. Januar 2018 um 00:00:00.000
    \item Endet am 03. Januar 2018 um 18:30:00.000
    \item Findet auf der Position 49.011978 N, 8.416377 E statt
    \item Die Benutzerkonten mit den IDs 200, 3 und 43378 sind als Teilnehmer
        eingetragen
\end{itemize}

Eine mögliche Kodierung der ausführlichen Beschreibung im JSON-Format kann wie
folgt aussehen:
\begin{lstlisting}[language=json,firstnumber=1]
{   "type": "event",
    "id": 2,
    "title": "Beispielverabredung 1010",
    "creator": 200,
    "time-start": 1514761200000,
    "time-end": 1515000600000,
    "latitude": 49.011978,
    "longitude": 8.416377,
    "participants": [
        {   "type": "account",
            "id": 3,
            "user": "w4rum"
        },
        {   "type": "account",
            "id": 200,
            "user": "notw4rum"
        },
        {   "type": "account",
            "id": 43378,
            "user": "absolutelynotw4rum"
        }
    ]
}
\end{lstlisting}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=1pt] (char) {\scriptsize #1};}}

Die normalisierte Darstellung dieser Verabredung sieht wie folgt aus.
Die Steuerzeichen werden durch \circled{1}, \circled{2}, \circled{3} etc.
dargestellt.\\
\textit{Hinweis: Die Zeilenumbrüche dienen nur der besseren Lesbarkeit und sind
nicht in der normalisierten Darstellung enthalten.}

\begin{lstlisting}[language=norm,firstnumber=1]
(*\circled{1}*)"event"(*\circled{2}*)2(*\circled{2}%
*)"Beispielverabredung 1010"(*\circled{2}*)200(*\circled{2}*)1514761200000
(*\circled{2}*)1515000600000(*\circled{2}*)49.011978(*\circled{2}%
*)8.416377(*\circled{2}*)(*\circled{4}*)(*\circled{1}*)"account"(*\circled{2}%
*)3(*\circled{2}*)"w4rum"(*\circled{2}*)"123abc"
(*\circled{3}*)(*\circled{5}*)(*\circled{1}*)"account"(*\circled{2}*)200(*%
\circled{2}*)"notw4rum"(*\circled{2}*)"blaa"(*\circled{3}\circled{5}%
\circled{1}*)"account"(*\circled{2}*)43378
(*\circled{2}*)"absolutelynotw4rum"(*\circled{2}*)"foobar"(*\circled{3}%
\circled{6}\circled{3}*)
\end{lstlisting}

\par Ein beispielhafter Algorithmus für die Normalisierung ist im folgenden
als Python-Implementierung angegeben:

\pythonexternal{scripts/normalize.py}

\end{document}
