\documentclass[parskip=full,11pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[useregional]{datetime2}
\usepackage[pdfborderstyle={/S/U/W 0}]{hyperref}
\usepackage[nameinlink]{cleveref}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{csquotes}
\usepackage{amsmath} % for $\text{}$
\usepackage{entwurf}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{bera}

\setlist{nosep}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}{\text{#2}}$}
\raggedbottom
\crefname{figure}{Abb}{Abb}

\newcommand\producttitle{treff.}
\hypersetup{
	pdftitle={Entwurf: \producttitle},
	bookmarks=true,
}

\graphicspath{ {images/} }

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}
\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\lstdefinelanguage{norm}{
    basicstyle=\normalfont\ttfamily,
    escapeinside={(*}{*)},
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
    language=Python,
    basicstyle=\normalfont\ttfamily,
    otherkeywords={self},
    keywordstyle=\ttb\color{deepblue},
    emph={normalize},
    emphstyle=\ttb\color{deepred},
    stringstyle=\color{deepgreen},
    frame=tb,
    showstringspaces=false,
    backgroundcolor=\color{background},
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    escapeinside={(*}{*)},
}}


% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% header & footer
\usepackage{scrlayer-scrpage}
%\lofoot{\today}
%\refoot{\today}
\pagestyle{scrheadings}

\title{\includegraphics[width = 80mm]{images/logo_crop.png}}
\subtitle{\huge Entwurf}
\author{Lukas Dippon
        \and Jens Kienle
        \and Matthias Noll
        \and Fabian Röpke
        \and Tim Schmidt
        \and Simon Vögele}

\begin{document}

\maketitle
\thispagestyle{empty} % removed page number from title

\pagebreak
\tableofcontents

%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Einleitung}

\subsection{Klient-Server-Architektur}
Für die App \enquote{treff.} soll eine Klient-Server-Architektur verwendet
werden, um die Interaktion mehrerer Nutzer zu realisieren.
Hierbei stellen die Geräte der Nutzer die Klienten dar und der Server
fungiert als Vermittler und Datenbank.
Hierbei werden leicht bedienbare Kommunikationsschnittstellen verwendet.
Dadurch wird ebenfalls eine starke Kopplung zwischen den in diesem Dokument
vorgestellten Implementierungen für Klient und Server vermieden.
Außerdem ermöglicht dies Kompatibilität mit alternativen Implementierungen
von sowohl Klienten als auch Servern.

\subsection{Funktion - Klient}
Der Klient speichert für den Nutzer relevante Daten in einer lokalen Datenbank
ab.
Diese können vom Nutzer eingesehen werden.
Anfragen des Nutzers werden in Form von Befehlen an den Server weitergegeben
(\ref{sec:commands}).
Diverse Daten wie beispielsweise GPS-Standort oder Chatnachrichten werden
dabei als Parameter der Befehle an den Server übergeben.

\subsection{Funktion - Server}
Der Server speichert die Daten der Nutzer in einer zentralen Datenbank, nimmt
Befehle der Klienten entgegen und verändert gegebenenfalls die Datensätze.
Bei Veränderung von Daten werden alle betroffenen Klienten darüber informiert,
welche daraufhin ihre lokalen Datensätze aktualisieren können. Außerdem
vermittelt er Anfragen der Klienten untereinander.

\pagebreak

\pagebreak
\subsection{Sprache dieses Dokumentes}
Während dieses Entwurfsdokument grundsätzlich in deutscher Sprache verfasst
ist, besitzen die in der Implementierung erscheinenden Entitäten, Relationen,
Klassen, Funktionen etc. englische Namen.
Diese Namen sind ebenfalls in Diagrammen und Schnittstellenspezifikationen
zu finden.
Zur besseren Zuordnung sind die hier verwendeten Übersetzungen im Folgenden
aufgeführt.

\begin{tabular}[t]{ l l }
    \textbf{Deutsch} & \textbf{Englisch}\\
    \hline
    Benutzerkonto & account\\
    Gruppe & usergroup\\
		Gruppenmitgliedschaft & groupmembership\\
		Abstimmung & poll\\
		Abstimmungsoption & polloption\\
		Verabredung & event\\
		Änderungen & update\\


\end{tabular}

%%%%%%%%%%%%%%%%%%%%
\pagebreak

\section{Semantisches Datenmodell}
Dieses Kapitel beschreibt den theoretischen Aufbau des in diesem Projekt
relevanten Ausschnitts der realen Welt.

\subsection{Benutzerkonto}
Ein Nutzer wird im System in Form eines Benutzerkontos repräsentiert.
Dieses wird durch eine eindeutige Identifikationsnummer 'id' identifiziert und
angesprochen. Jedes Benutzerkonto beinhaltet den Nutzernamen 'username' und
die verwendete E-Mailadresse 'email' des zugehörigen Nutzers.
Für das Benutzerkonto wird desweiteren der Hash seines Passworts und des Salts,
sowie das verwendete Salt gespeichert.
Außerdem wird durch die Werte 'lon' und 'lat' Längen- und Breitengrad der
aktuellen Position des Nutzers und durch 'timemeasured' der letzte
Messzeitpunkt dieser Position gespeichert.
Ein Benutzerkonto beinhaltet eine beliebig große Menge von Benutzerkonten,
den Kontakten/Freunden des Nutzers. Diese Menge darf leer sein, jedoch nicht
das eigene Benutzerkonto beinhalten.
Ein Benutzerkonto beinhaltet eine weitere,
beliebig große Menge von Benutzerkonten.
Diese Menge stellt die vom Nutzer blockierten Benutzerkonten dar und darf leer
sein, jedoch nicht das eigene Benutzerkonto beinhalten. Ein Benutzerkonto kann
Verabredungen erstellen und an solchen teilnehmen.
Ein Benutzerkonto kann Abstimmungen innerhalb einer Gruppe erstellen und für
deren Optionen abstimmen.
Jedes Benutzerkonto besitzt eine Gruppenmitgliedschaft für jede Gruppe, in der
es Mitglied ist.
Ein Benutzerkonto hat eine Menge von Updates die dieses Benutzerkonto
betreffen.
%TODO Warum haben wir was wie gemacht

\svgFigure{erd-account}{Benutzerkonto}{300pt}
\pagebreak

\subsection{Gruppenmitgliedschaft}
Eine Gruppenmitgliedschaft gehört zu exakt einem Benutzerkonto und zu exakt
einer Gruppe. Sie wird durch eine eindeutige Identifikationsnummer 'id'
identifiziert und angesprochen. Außerdem beinhaltet sie boolsche Werte,
die angeben, welche Rechte das zugehörige Benutzerkonto in der zugehörigen
Gruppe hat. Diese Rechte beziehen sich dabei immer auf die zugehörige Gruppe
der Gruppenmitgliedschaft und sind nur in dieser gültig.\\
\begin{tabular}[t]{ l l }
    \textbf{Berechtigung} & \textbf{berechtigt dazu}\\
    \hline
    change-group-name & den Namen der Gruppe zu ändern.\\
    manage-members & Nutzer bzw deren Benutzerkonto in die Gruppe\\
     & hinzuzufügen und Gruppenmitglieder zu entfernen.\\
    change-permissions & die Gruppenberechtigungen der
        Gruppenmitglieder zu\\
     & bearbeiten.\\
    create-event & Verabredungen zu erstellen.\\
    edit-any-event & Verabredungen zu bearbeiten, welche man nicht
        selbst\\
     & erstellt hat.\\
    create-poll & Abstimmungen zu erstellen.\\
    edit-any-poll & Abstimmungen zu bearbeiten, welche man nicht
    selbst\\
     & erstellt hat.\\
\end{tabular}

%TODO Warum haben wir was wie gemacht
Diese Abbildung der Gruppenmitgliedschaften wurde gewählt um eine
Dreiecksbeziehung zwischen Benutzerkonto,
Gruppe und den Berechtigungen aufzulösen.

\svgFigure{erd-groupmembership}{Gruppenmitgliedschaft}{300pt}
\pagebreak


\subsection{Gruppe}
Eine Gruppe ist eine Ansammlung von Nutzern. Sie wird durch eine eindeutige
Identifikationsnummer 'id' identifiziert und angesprochen. Eine Gruppe besitzt
einen Namen 'name' und beinhaltet eine beliebig große Menge der
Gruppenmitgliedschaften aller Nutzer, die Teil der Gruppe sind.
Da eine Gruppe ohne Mitglieder nicht existieren kann, darf diese Menge nicht
leer sein. Außerdem beinhaltet eine Gruppe eine beliebig große Menge an
Verabredungen und eine beliebig große Menge von Abstimmungen.
Da zu gewissen Zeitpunkten keine Verabredungen vereinbart oder in Planung sein
können, dürfen beide Mengen leer sein.
%TODO Warum haben wir was wie gemacht
\\
\\
\\

\svgFigure{erd-group}{Gruppe}{200pt}
\pagebreak


\subsection{Abstimmung}
Eine Abstimmung wird durch eine eindeutige Identifikationsnummer 'id'
identifiziert und angesprochen.
Eine Abstimmung besteht aus einer Frage, die für diese Abstimmung gestellt wird
und einem Wahrheitswert der festlegt,
ob die Abstimmung dem Nutzer erlaubt für mehrere oder nur für eine Option zu
stimmen.
Außerdem beinhaltet sie eine beliebig große Menge von Optionen der Abstimmung,
jedoch mindestens eine.
Desweiteren speichert die Abstimmung ein Benutzerkonto, ihren Ersteller.
%TODO Warum haben wir was wie gemacht
\\
\\
\\

\svgFigure{erd-poll}{Abstimmung}{280pt}
\pagebreak


\subsection{Abstimmungsoption}
Die Abstimmungsoption wird durch eine eindeutige Identifikationsnummer 'id'
identifiziert und angesprochen.
Die Option speichert ihren Start- und Endzeitpunkt starttime und endtime,
sowie ihre Position in Form der Werte 'lon' und 'lat' als Längen- und
Breitengrad.
Weiterhin wird eine beliebige Menge von Nutzern bzw deren Benutzerkonten
gespeichert, die für diese Option gestimmt haben.
%TODO Warum haben wir was wie gemacht
\\
\\
\\

\svgFigure{erd-polloption}{Abstimmungsoption}{300pt}
\pagebreak


\subsection{Verabredung}
Eine Verabredung wird durch eine eindeutige Identifikationsnummer 'id'
identifiziert und angesprochen. Sie besteht aus einem Namen 'title', einem
Start- sowie einem Endzeitpunkt 'timestart' und 'timeend',
und Längen- sowie Breitengrad 'lon' und 'lat' des Treffpunktes. Sie speichert
ihren Ersteller und die Gruppe, in der sie erstellt wurde.
Eine Verabredung beinhaltet eine beliebig große Teilmenge von Mitgliedern der
zugehörigen Gruppe.
Diese Menge stellt die Teilnehmer der Verabredung dar und darf auch leer sein.
%TODO Warum haben wir was wie gemacht
\\
\\
\\

\svgFigure{erd-event}{Verabredung}{350pt}
\pagebreak

\subsection{Änderung}
Eine Änderung wird durch eine eindeutige Identifikationsnummer 'id'
identifiziert und angesprochen. Sie besteht aus einem String 'updateString',
dieser beschreibt eine Änderung in der Datenbank.
Eine Änderung beinhaltet eine beliebig große Menge von Benutzerkonten die durch
diese Änderung betroffen sind.
Diese Entitäten werden verwendet um sich zu speichern welche Änderungen der
Datenbank an den Klienten in dem ein Benutzerkonto eingeloggt ist übertragen
werden müssen.
%TODO Warum haben wir was wie gemacht
\\
\\
\\

\svgFigure{erd-update}{Änderung}{350pt}
\pagebreak



\subsection{Gesamtkonstrukt}
\begin{figure}[!htb]
    \centering
    \def\svgwidth{540pt}
    \rotatebox{90}{\input{build/images/erd-complete.pdf_tex}}
    \caption{Gesamtkonstrukt}
    \label{fig:erd-complete}
\end{figure}

\section{Aufbau und internes Verhalten - Klient}

\subsection{Aufbau}

Der Klient, also die App selbst, besteht grundsätzlich aus zwei Teilen:
der Grafischen Benutzeroberfläche (GBO), also dem für den Benutzer
sichtbaren Teil und der im Hintergrund ablaufenden Datenverwaltung.
Die GBO bietet dem Nutzer eine Oberfläche, mit der er einfach auf alle
Funktionen der App zugreifen kann.
Dabei ist es wichtig, die beiden Teile klar voneinander zu entkoppeln,
um z.B. Datenverlust und inkonsistentes Verhalten zu verhindern, das sonst
bei Aktionen wie dem Pausieren oder Drehen der App auftreten kann.

\subsubsection{MVVM}
Um diese Entkopplung zu erreichen kommt die MVVM-Architektur
(Model-View-ViewModel) zum Einsatz (siehe Abb.\ref{fig:structure}).
Das bedeutet, dass der Klient in 3 wesentliche Schichten gegliedert ist:
\begin{itemize}
	\item Die View-Ebene (meistens gegeben durch Activities oder Fragments)
        behandeln Eingaben des Nutzers und bestimmen das Aussehen der
        Benutzeroberfläche.
	\item Das Model stellt eine Abstraktion der zugrunde liegenden
        Datenstruktur zur Verfügung. In diesem Fall handelt es sich dabei um
        Repositories, welche sowohl auf eine lokale Datenbank zugreifen können,
        als auch über einen Netzwerkadapter Updates vom Server anfordern
        können.
	\item Die Verbindung zwischen der Model- und der View-Ebene stellen
        ViewModels dar. Diese stellen der darüber liegenden View Verbindungen
        zu allen benötigten Daten zur Verfügung.
	    Wichtig ist dieser Schritt deshalb, weil ViewModels im Gegensatz zu
        View-Objekten auch Configuration-changes überleben, die Daten also z.B.
        nach dem Drehen des Geräts weiterhin zur Verfügung stehen und sofort
        wieder von der View verwendet werden können.
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width = \columnwidth / 3 * 2]{database.png}
	\captionof{figure}{Bei dieser Darstellung sind View und ViewModel nicht als
        tatsächliche packages zu verstehen, sondern dienen lediglich der
        vereinfachten Darstellung. Ebenso wenig ist dieses Diagramm
        vollständig. Fehlende Klassen verhalten sich allerdings äquivalent.}
    \label{fig:structure}
\end{figure}


\pagebreak

\subsection{Bestandteile der GBO}

Die GBO besteht im Wesentlichen aus den
folgenden vier Teilen: Den wahrscheinlich wichtigsten Teil stellt die Home-Activity
dar, auf dem der Nutzer in vier Tabs auf alle Gruppen, Verabredungen, Freunde und
die Karte zugreifen kann. Details zu einer Gruppe, sowie alle in dieser Gruppe
geplanten Verabredungen können in einer eigenen Activity eingesehen werden.
Außerdem wird eine Activity benötigt, die es dem Nutzer erlaubt, sich anzumelden
bzw. zu registrieren. Die letzte wichtige Komponente stellt die Settings-Activity
dar, in welcher der Nutzer Benutzerkonto-Einstellungen vornehmen kann. Eine genaue
Auflistung aller Klassen und Packages findet sich unter Abb.\ref{fig:classes}.

\begin{figure}
	\centering
	\includegraphics[width = \columnwidth / 100 * 95]{treff2.pdf}
	\captionof{figure}{Sämtliche Klassen und Packages des treff-Klients. Eine
	Darstellung als UML-Klassendiagramm wäre unübersichtlich und nicht sinnvoll
	gewesen.}
	\label{fig:classes}
\end{figure}

\pagebreak
\subsubsection{HomeActivity}
Diese Activity stellt den wichtigsten Teil der Anwendung dar, da der Nutzer
von hier aus auf alle weiteren Funktionen zugreifen kann.
Die unterschiedlichen Tabs mit Karte, Freundes-, Gruppen-, und
Verabredungsliste werden dabei als Fragments realisiert, welche von einem
ViewPagerAdapter verwaltet werden. Bis auf das MapFragment unterscheiden sich
die Fragments selbst kaum voneinander, da alle anderen lediglich eine Liste
darstellen müssen. Um dies zu bewerkstelligen kommt eine Recyclerview zum
Einsatz, da sie flexibler und weniger ressourcenbelastend ist als zuvor
übliche Listviews. Jede dieser Recyclerviews besteht im wesentlichen aus
drei Teilen:
\begin{itemize}
	\item{'ViewHolder'} ist dafür verantwortlich, die Daten eines einzelnen
        Elements der Liste zu behalten und die Verbindung zum Layout eines
        Listeneintrags herzustellen.
	\item{'Adapter'} stellt die Verbindung zwischen der Menge an Daten, die
        angezeigt werden soll und den ViewHoldern dar.
	\item{'Layoutmanager'} bestimmt, wie die einzelnen Elemente der Liste
        zueinander angeordnet sein sollen
        (Im Falle einer Liste also ein LinearLayoutManager).
\end{itemize}
Für den LayoutManager existiert bereits eine fertige Implementierung, der
LinearLayoutManager, welcher die Items als Liste darstellt. Sowohl der
ViewHolder als auch der Adapter wird jedoch für den entsprechenden
Verwendungszweck von uns erweitert, wie in Abb.\ref{fig:lists} zu erkennen ist.

\begin{figure}
    \centering
    \includegraphics[width = \columnwidth]{lists.png}
    \captionof{figure}{Diese Darstellung zeigt die Vererbungen und Beziehungen
    im Aufbau einer RecyclerView am Beispiel der FriendList. Group- und
    EventList verhalten sich allerdings äquivalent.}
	\label{fig:lists}
\end{figure}

\pagebreak
Der einzige wesentlich andere Tab auf dem Homescreen stellt das MapFragment dar.
Es ist zugleich der für den Nutzer wohl wichtigste Teil, da hier alle
Informationen angezeigt werden, die unsere Anwendung bereitstellt. Dies
beinhaltet in erster Linie die Standorte von befreundeten Benutzern oder andere
Mitglieder in Gruppen, aber auch Events werden hier angezeigt. Dabei beruht die
Darstellung der Karte auf einer MapView, welche mithilfe von
osmdroid\footnote{\url{https://github.com/osmdroid/osmdroid}} die
OpenStreetMap\footnote{\url{https://www.openstreetmap.org}} (OSM) anzeigt.
Der osmdroid Ersatz für Android's MapView Klasse bietet auch bereits die
Möglichkeit, unterschiedliche Markierungen auf der Karte anzubringen. Um die
relevanten Daten wie Nutzerstandorte bereit zu stellen kommt wieder ein angepasstes
MapViewModel zu Einsatz. Zusätzlich soll der Nutzer Filter einstellen können,
um die Art angezeigter Marker einzuschränken. Diese Einstellung wird ebenfalls
in dem ViewModel abgelegt um Persistenz über Drehung etc. zu garantieren. Der
Filter kann vom Benutzer über einen Android-eigenen Dialog angepasst werden.

\svgFigure{activity-home-layout}{Layout der Home-Activity}{300pt}

Das XML-Layout der Activity basiert auf einem DrawerLayout. Dessen erstes Element
ist der eigentliche Bildschirm, den der Nutzer sieht Das zweite ist ein
\enquote{Drawer}, kann also herausgeschoben werden. Im DrawerLayout sind wiederum
Ein AppBarLayout mit der Toolbar und einem TabLayout sowie ein ViewPager, der
immer ein Fragment hält. Das AppBarLayout gruppiert die Toolbar mit dem Appnamen und
dem Hamburgermenü und das TabLayout, welches die Titel der Tabs anzeigt.
\\Die NavigationView enthält ein Menü mit einer Gruppe an Items; diese bilden mit
Namen und Icon versehen die oberste Navigationsebene der App.

\subsubsection{GroupActivity}

Wie bereits die HomeActivity dient die GroupActivity lediglich als Host für
mehrere Fragments, welche als Tabs angeordnet werden. In diesem Fall
handelt es sich dabei um ein GroupEventFragment, GroupChatFragment und ein
MapFragment. In ersterem wird eine Liste aller in dieser Gruppe angelegten
Verabredungen und Abstimmungen angezeigt, das GroupChatFragment zeigt die
Nachrichten des Gruppenchats in chronologischer Reihenfolge an und das
MapFragment zeigt eine Karte mit Verbredungen und Nutzern der Gruppe.
Zusätzlich kann der Nutzer über das GroupSettingsFragment eine Liste aller
Gruppenmitglieder einsehen und auf Verwaltungsoptionen der Gruppe zugreifen.
Jedes dieser Fragments verwendet dafür wiederum eine RecyclerView
(siehe Abb.\ref{fig:lists}) zum Anzeigen von Verabredungen, Abstimmungen
bzw. Benutzern.

\subsubsection{LoginActivity}

Die LoginActivity wird bei jedem neuen Start der Anwendung geöffnet. Sie ist
dafür zuständig, über den RequestEncoder eine Synchronisation mit dem Server
anzufordern. Während dieses Prozesses stellt sie das Layout eines
Ladebildschirms dar. Ist die Synchronisation erfolgreich, startet sie die
HomeActivity und beendet sich selbst. Tritt ein Authentifizierungsproblem auf,
weil zum Beispiel aktuell gar kein, oder ein nicht gültiger Token vergeben ist,
wird der Nutzer auf den eigentlichen Anmeldebildschirm weitergeleitet. Sowohl der
Anmelde-, als auch der Registrierungsbildschirm werden durch Fragments realisiert.
Per Knopfdruck kann jeweils das andere Fragment angezeigt werden. Hat der
Nutzer seine Authentifizierungsdetails vollständig eingegeben und den
\enquote{Registrieren} bzw. \enquote{Anmelden} Knopf betätigt, werden die Daten
durch das Fragment an den RequestEncoder übergeben. Dieser gibt dann zurück, ob
die Anfrage erfolgreich war. Dementsprechend wird der Nutzer zur HomeActivity
weitergeleitet, oder ein für den Nutzer verständlicher Fehler wird durch das
aktuelle Fragment angezeigt.

\subsubsection{SettingsActivity}

Auf die Einstellungen kann der Nutzer über den NavigationDrawer der HomeActivity
zugreifen. Hier hat er die Möglichkeit, Account-Einstellungen vorzunehmen,
wie beispielsweise den Nutzernamen oder das Passwort zu ändern oder diverse
'Mutefunktionen' zu bearbeiten. Änderungen am Account werden dabei vom ViewModel
direkt an den RequestEncoder weitergegeben, da sie keine gespeicherten Entitäten
betreffen. Darin unterscheiden sich die Settings von den meisten anderen Activities.
Einstellungen wie stummschalten, welche nur den Nutzer selbst betreffen und für
den Server nicht relevant sind, werden hingegen in den SharedPreferences
abgelegt.

\subsection{Bestandteile der Datenverarbeitung}

Die Datenverarbeitung beruht auf einer Unterteilung in eine lokale Datenbank
und die Verbindung zum Server, welche unabhängig voneinander agieren. Um stets
zu garantieren, dass diese Datenquellen synchronisiert werden kommen
Repositories zum Einsatz. Die Struktur des gesamten Datenverarbeitung lässt
sich in Abb.\ref{fig:model} erkennen. Die Aufgaben und der Aufbau der einzelnen
Bestandteile sind wie folgt:

\subsubsection{Lokale Datenbank}

Die lokale SQLite-Datenbank hat die Aufgabe, alle für den konkreten Client
relevanten Daten auf dem Gerät zu cachen und zu verhindern, dass alle
Informationen stets vom Server geholt werden müssen.
Sie wird von der Android Library
Room\footnote{\url{https://developer.android.com/topic/libraries/architecture/room.html}}
erstellt, welche zugleich eine Abstraktionsebene zu dieser
Datenbank bereitstellt. Diese erlaubt es, fließend mit der Datenbank zu
interagieren. Dazu werden Data Access Objects (DAOs) verwendet. Diese
wandeln Aufrufe von Java-Methoden in SQL-Queries, um Daten in für Java
sinnvollen Formaten aus der Datenbank zu lesen. Im Fall von treff. sollen zum
Beispiel vor allem Nutzer-, Gruppen-, und Verabredungs-Details angezeigt
werden, welche entsprechend gespeichert werden müssen. Das bedeutet, dass unter
anderem ein UserDao, ein UserGroupDao, sowie ein EventDao verwendet werden um
diese Objekte in der Datenbank zu repräsentieren.

\subsubsection{Verbindung zum Server}
\begin{description}
\item[RequestEncoder]\hfill \\
Der RequestEncoder ist die Schnittstelle zwischen dem Repository zur Datenverarbeitung
und dem ConnectionHandler, welcher mit dem Server kommuniziert. Er stellt für jede Anfrage an den
Server eine Methode bereit. Der Ablauf einer solchen Methode sieht immer wie folgt aus:
1. Die Anfragen und Parameter werden in das festgelegte JSON Format gebracht.
2. Die formatierte Anfrage wird an den ConnectionHandler übergeben, um sie zum Server zu senden.
3. Nach der Abarbeitung durch den Server wird vom ConnectionHandler die Antwort im JSON
Format entgegengenommen.
4. Die Antwort wird zerlegt und in passende primitive Datentypen oder Objekte umgewandelt.
Diese werden dem Aufrufer zurückgegeben.
Die einzige Ausnahme zu diesem Vorgehen stellen die Methoden zum Anmelden und
Registrieren dar. Denn sie sind noch zusätzlich zur Formatierung für das Hashen
der Passwörter zuständig.
Zudem ist der RequestEncoder dafür zuständig den Authentifizierungstoken zu verwalten.
Er hat die Kontrolle über das Shared Preference Objekt, welches den Token speichert.
\item[ConnectionHandler]\hfill \\
Der ConnectionHandler ist die einzige Möglichkeit, Anfragen an den Server zu
senden. Er stellt eine Socket-Verbindung zum Server her und er leitet über
einen PrintWriter, als Strings gegebene Befehle an den Server weiter. Hierfür
stellt er die Methode sendRequest bereit, welche allerdings nur durch den
Request Encoder aufgerufen wird. Die Antworten des Servers liest er auf
einem BufferedReader wieder aus und gibt sie an den RequestEncoder zurück.
Damit der Nutzer bei einer schlechten Internetverbindung nicht gezwungen ist,
zum Beispiel auf das Senden einer Nachricht warten zu müssen, wird die Kommunikation
natürlich asynchron im Hintergrund ausgeführt.
\end{description}

\subsubsection{Repositories}

Das entscheidende Verbindungsglied zwischen den beiden oben genannten
Komponenten stellen die Repositories dar. Wie auch von den DAOs gibt es von
ihnen eines pro Entität, wobei beispielsweise Gruppen und
Gruppenmitgliedschaften zusammengefasst sind. Repositories werden
direkt von den ViewModels angessprochen und ihre Aufgabe ist es, Daten für diese
möglichst schnell bereitzustellen und gleichzeitig dafür zu sorgen, dass die
gecachten Daten in der Datenbank immer möglichst synchron zu den Serverdaten
sind, ohne dass sich das ViewModel selbst darum kümmern muss. Die typische
Vorgehensweise bei einem Aufruf des Repositories, wenn ein ViewModel bestimmte
Daten verlangt, ist immer sehr ähnlich. Zunächst wird eine asynchrone Anfrage
an den RequestEncoder gestellt, welche überprüfen soll, ob sich die betroffenen
Daten seit der letzten Synchronisation verändert haben. Daraufhin werden die
angeforderten Daten als LiveData (genaueres in \ref{sec:livedata}) aus der
Datenbank angefordert und an das
ViewModel zurückgegeben. Falls sich die Serverdaten tatsächlich verändert
haben, erhält das Repository nun Rückmeldung darüber und kann diese
Veränderungen in die lokale Datenbank übernehmen. Da die Datanbank mit LiveData
kompatibel ist löst dies automatisch eine Aktualisierung der View aus, was
bedeutet, dass dort die aktuellsten Daten angezeigt werden können.

\begin{figure}
	\centering
	\includegraphics[width = \columnwidth]{model.png}
	\captionof{figure}{Die Der Aufbau der Datenverarbeitung am Beispiel von
	Usern, Events und UserGroups. Weder das repositories-, noch das
	database-package sind dabei vollständig, fehlende Klassen und auch fehlende
	Methoden wurden für eine bessere Lesbarkeit ausgelassen.}
	\label{fig:model}
\end{figure}

\pagebreak
\subsubsection{GPSProider}

Der GPS Provider ist dafür zuständig, die Positionsdaten des Nutzers für den
Server und das Map ViewModel bereitzustellen. Obwohl Android mit dem
LocationManager und dem LocationListener über eine Beobachter Schnittstelle
verfügt, ist dieser Zwischenschritt über eine Eigene Klasse notwendig. Denn so
kann man die durch GPS ermittelte Position mit derjenigen vergleichen, welche
über Netzwerkdaten errechnet wurde. Dadurch wird sichergestellt, dass immer
nur die aktuell bestmögliche Position beachtet wird. Die Kommunikation mit dem
ViewModel und dem RequestEncoder erfolgt ähnlich dem Beobachter Modell. Von
beiden Klassen kann sich maximal ein Objekt, welches über jede
Positionsänderung informiert werden soll, über die subscribe Methode anmelden.
Durch die Trennung von ViewModel und RequestEncoder wird es auch ermöglicht die
Position zu übertragen ohne eine Karte anzuzeigen, bzw. eine Karte mit Standort
anzuzeigen, während die Übertragung an den Server nicht erwünscht ist. Zudem
erbt die GPSProvider Klasse von der IntentService Klasse von Android. So wird es
möglich, die Positionsbestimmung / Übertragung auch nach dem Schließen der
Anwendung aufrechtzuerhalten.


\subsection{Kommunikation von GBO und Datenverarbeitung}
% Zusammenspiel von GBO und Datenverarbeitung
% (Fließtext und UML-Klassendiagramme, ggf Sequenzdiagramme)
Die Kommunikation von GBO und Datenverarbeitung findet im wesentlichen zwischen
ViewModels und Repositories statt.

\subsubsection{LiveData} \label{sec:livedata}
Um sicherzustellen, dass die View stets mit dem Model synchronisiert ist,
bietet Android eine Wrapper-Klasse namens LiveData an, welche von View-Elementen
\enquote{observed} werden kann. Wenn sich nun durch eine Änderung der Datenbank
die anzuzeigenden Daten verändern, werden alle Observer (also die View) darüber
benachrichtigt und können entsprechend angepasst werden.
Room ermöglicht es, dass aus der SQL-Datenbank LiveData Objekte generiert
werden und stellt sicher, dass diese bei Änderungen der Datenbank auch die
nötigen onChange() Methoden aufrufen. Der Ablauf eines solchen Updates lässt
sich in Abb.\ref{fig:datafetch} nachvollziehen.

\begin{figure}
	\centering
	\includegraphics[width = \paperheight / 30 * 19, angle = 90]{datafetch.png}
	\captionof{figure}{Dieser Ablauf steht beispielhaft für fast alle Zugriffe
		auf die Datenbank. Im oberen Teil ist zu sehen, wie ein View-Objekt (in
		diesem Fall fragment) sich als Observer eines LiveData Objekts eintragen
		kann. Im unteren Teil ist zu sehen, wie dieses auf eine Änderung
		reagiert und das fragment benachrichtigt.}
	\label{fig:datafetch}
\end{figure}


\subsubsection{Fehlerbehandlung} \label{sec:error}

Es kann vorkommen, dass Anfragen an den Server fehlerhaft sind oder bestimmte
Operationen nicht ausgeführt werden können (beispielsweise wenn ein Nutzername
schon vergeben ist). Der Server liefert dann eine Fehlermeldung zurück, die vom
Client behandelt werden muss. Diese Aufgabe übernimmt der RequestEncoder.
Sämtliche Fehler, die auftreten können sind dazu mit ihren Fehlercodes (siehe
\ref{sec:errorcodes}) in einem Enum hinterlegt. Außerdem ist in diesem Enum
festgelegt, ob der Fehler für den Nutzer relevant ist (z.B. Fehler 010:
Nutzername vergeben) oder programmintern behandelt werden muss (z.B. Fehler
310: Messzeitpunkt liegt in der Zukunft). Davon abhängig wirft der
RequestEncoder unterschiedliche Exceptions (IllegalArgumentException bei
fehlerhafter Benutzereingabe bzw. InternalError bei internem Problem). Je nach
konkreter Implementierung werden diese an unterschiedlichen Stellen des
Programms wieder aufgefangen, allerdings werden IllegalArgumentExceptions bis
zur View-Ebene weitergegeben, da dort Fehlerdialoge erzeugt werden können, um
den Nutzer über das Problem zu informieren.




%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Aufbau und internes Verhalten - Server}

\subsection{Aufbau}
% Aufteilung der Funktionalitäten auf seperate Klassen;
% Zusammenspiel dieser Klassen (Fließtext und UML-Klassendiagramme,
% ggf Sequenzdiagramme)
Der Server besteht aus drei verschiedenen Bestandteilen:

\begin{figure}[!htb]
    \centering
    \includegraphics[width = \columnwidth / 3 * 2]{build/uml/server.png}
    \captionof{figure}{Klassen-Diagramm der wichtigen Klassen des Servers}
	\label{fig:serverclassdiagram}
\end{figure}

\subsubsection{Netzwerkkommunikation}
%Klassendiagramm(Server, ConnectionHandler und Kontext)
Die Klasse 'Server' ist die Hauptklasse des Servers.
Diese bereitet beim Hochfahren des Servers Verbindungen zur Datenbank vor und
ist für die Netzwerkkommunikation zuständig.
Dazu wird für jede Verbindung, welche ein Klient zum Server öffnet,
ein ConnectionHandler erstellt.
Dieser gibt die bei Erhalt von Anfragen diese an einen neuen RequestHandler
weiter und sendet die vom RequestHandler produzierte Antwort zurück an den
Klienten.
Da die Anfragen eines Benutzers sequentiell abgearbeitet werden sollen, ruft
der ConnectionHandler den RequestHandler synchron auf.
Während der Anfragenbearbeitung landen weitere Anfragen in einem Puffer.
Neben allen anderen existierenden Server-Befehlen, die vom Klienten gesendet
werden können und pro Anfrage eine Antwort liefern, gibt es zusätzlich einen
Befehl, der die bestehende Verbindung in eine Aktualisierungsverbindung
umwandelt.
Weitere Details zu Aktualiserungsverbindungen sind im Kapitel
\ref{sec:get-updates} spezifiziert.
Für diese Art des Aktualisierungsabrufes ist die
AccountUpdateListener-Implementierung PersistentConnection zuständig.

\subsubsection{(De-)Kodierung von Anfragen}
%Klassendiagramm RequestHandler und Kontext
Die Klasse RequestHandler erhält die kodierten Anfragen des Klienten und
ist für die Dekodierung und Weiterleitung der Anfragen, sowie für
die Kodierung und die Rückgabe der Antworten an die ConnectionHandler zuständig.

\subsubsection{Datenbankzugriff}
Die Entitäten des semantisches Datenmodells werden durch Adapterklassen für
eine beliebige Datenbankstruktur repräsentiert.
Die Entkopplung von einer konkreten Datenbankstruktur wird dadurch erreicht,
das diese Adapterklassen durch Interfaces abstrahiert werden.
Eine Implementierung dieser Interfaces für eine MySQL-Datenbank ist ebenfalls
Teil dieses Entwurfs.

\par Referenzen auf Datenbankobjekte können nur durch Methoden anderer
Datenbankobjekte erhalten werden.
So ist es beispielsweise nur möglich, auf ein Usergroup-Objekt zuzugreifen,
wenn eine Referenz auf ein Account-Objekt, das Mitglied der Gruppe ist,
vorliegt.
Des weiteren können Verabredungen und Abstimmungen nur mittels Gruppen
referenziert werden und Abstimmungsoptionen nur mittels Abstimmungen.
Der erste Zugriff auf eine Datenbankstruktur erfolgt über einen einzelnen,
zentralen Einstiegspunkt, nämlich den AccountManager.
Über diesen ist es möglich, Referenzen auf Account-Instanzen zu erhalten.

\par Die MySQL-Implementierungen der oben genannten Interfaces halten selbst
keine Daten außer der ID der Entität, die sie repräsentieren.
Methoden, die auf andere Attribute zugreifen, erreichen dies durch das Abrufen
bzw. Editieren der jeweiligen Werte aus der MySQL-Datenbank mittels
vorgefertigten MySQL-Befehlen.
Die Implementierung des AccountManagers, der EntityManagerSQL, dient den
anderen MySQL-Implementierungen gleichzeitig als Schnittstelle zum
MySQL-Server, indem der EntityManagerSQL eine paketweit sichtbare Methode zum
Ausführen von MySQL-Befehlen zur Verfügung steht.

\par Die folgenden zwei Klassendiagramme (Abbildung
    \ref{fig:server-db-adapter1} und \ref{fig:server-db-adapter2} beinhalten
    die oben beschriebenen Klassen.  Die Teilung in zwei Diagramme dient
    lediglich der besseren Lesbarkeit.
Die Klassen in beiden Diagrammen liegen im selben \enquote{sql}- bzw.
\enquote{interfaces}-Paket.

\begin{figure}[!htb]
    \centering
    \includegraphics[width = \columnwidth / 2 * 3, angle = 90]
        {build/uml/server-database-adapters-p1.png}
    \captionof{figure}{Klassen-Diagramm für den Datenbankzugriff relevanten
    Pakete (Teil 1)}
	\label{fig:server-db-adapter1}
\end{figure}
\pagebreak

\begin{figure}[!htb]
    \centering
    \includegraphics[width = \columnwidth / 2 * 3, angle = 90]
        {build/uml/server-database-adapters-p2.png}
    \captionof{figure}{Klassen-Diagramm für den Datenbankzugriff relevanten
    Pakete (Teil 2)}
	\label{fig:server-db-adapter1}
\end{figure}
\pagebreak

\subsection{Bestandteile des Servers}
% Aufbau und genaue Funktionalität dieser Klassen
% [z.B. Datenbank, Schnittstelle zum Klient]
% (Fließtext und UML-Klassendiagramme, ggf Sequenzdiagramme)

\begin{figure}[!htb]
	\centering
	\includegraphics[width = \columnwidth / 100 * 90]{treff3.png}
	\captionof{figure}{Sämtliche Klassen und Packages des treff-Servers. Eine
	Darstellung als UML-Klassendiagramm wäre unübersichtlich und nicht sinnvoll
	gewesen.}
	\label{fig:classesserver}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{Beispielhafter Ablauf einer Anfrage eines Klienten}

\begin{figure}[!htb]
    \centering
    \includegraphics[width = \columnwidth]
		{build/uml/get-event-details-sequence.png}
    \captionof{figure}{Sequenz-Diagramm des Befehls 'get-event-details'}
	\label{fig:sequence-diagram}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Kommunikation zwischen Klient und Server}
% Zusammenspiel von Klient und Server
% (Fließtext und Sequenzdiagram, ggf UML-Klassendiagram)
% TODO: JSON verlinken / footnote
% TODO: Alphabet und Escapes genau festlegen
Klient und Server kommunizieren mittels Nachrichten im JSON-Format.
Die oberste Ebene jeder Nachricht bildet ein einzelnes JSON-Objekt.
Parameter, Rückgabewerte und Fehlercodes werden als Eigenschaften dieses
Objektes kodiert.
Eine Anfrage beinhaltet immer mindestens eine Eigenschaft mit dem Schlüssel
\textbf{cmd}.
Die Namen der im folgenden definierten Befehle sind exakt die Werte, die bei
Kodierung als Nachricht den Wert der \textbf{cmd}-Eigenschaft bilden müssen.
Diese Namen sind als Zeichenketten zu kodieren.
\\Wird während der Ausführung des Befehls ein Fehler gefunden, möglicherweise
durch übermittelte Parameter bedingt, wird nur ein Fehlercode mit dem Schlüssel
\textbf{error} zurückgegeben. Die Bedeutung der Fehlercodes wird ebenfalls im
folgenden definiert.

\subsection{Befehle}\label{sec:commands}

\apiErrorNew{username-already-in-use}{000}{Nutzername schon vergeben}
\apiErrorNew{invalid-email}{010}{Email nicht gültig}
\apiErrorNew{token-invalid}{020}{Authentifizierungstoken ungültig}
\apiErrorNew{cred-wrong}{030}{Nutzername/Passwort-Kombination ungültig}

\apiErrorNew{no-permission-group-edit}{100}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um die Gruppe zu editieren}
\apiErrorNew{no-permission-members-edit}{101}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um die Liste an Gruppenmitgliedern zu editieren}
\apiErrorNew{no-permission-event-create}{110}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um in der angegebenen Gruppe Verabredungen zu erstellen}
\apiErrorNew{no-permission-event-edit}{111}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um die Verabredung zu editieren}
\apiErrorNew{no-permission-poll-create}{120}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um in der angegebenen Gruppe Abstimmung zu erstellen}
\apiErrorNew{no-permission-poll-edit}{121}{Das Benutzerkonto besitzt nicht
die nötigen Rechte, um die Abstimmung zu editieren}
\apiErrorNew{no-permission-permissions-edit}{122}{Das Benutzerkonto besitzt
nicht die nötigen Rechte, um die Berechtigungen zu editieren}

\apiErrorNew{username-invalid}{200}{Nutzername ungültig}
\apiErrorNew{user-id-invalid}{201}{Mindestens eine
Benutzerkonto-Identifikationsnummer ungültig}
\apiErrorNew{group-id-invalid}{210}{Gruppen-Identifikationsnummer ungültig
oder Benutzerkonto nicht Teil der Gruppe}
\apiErrorNew{event-id-invalid}{220}{Verabredungs-Identifikationsnummer ungültig}
\apiErrorNew{poll-id-invalid}{230}{Abstimmungs-Identifikationsnummer ungültig}
\apiErrorNew{poll-option-id-invalid}{240}
{Abstimmungsoptions-Identifikationsnummer ungültig}

\apiErrorNew{time-end-in-past}{300}{Mindestens ein Endzeitpunkt liegt
in der Vergangenheit}
\apiErrorNew{time-end-start-conflict}{301}{Mindestens ein Endzeitpunkt liegt
nicht nach dem dazugehörigen Startzeitpunkt}
\apiErrorNew{time-measured-future}{310}{Messzeitpunkt liegt zu weit in der
Zukunft}

\apiErrorNew{not-in-contacts}{400}{Benutzerkonto nicht in
der eigenen Kontaktliste}
\apiErrorNew{being-blocked}{401}{Benutzerkonto wird vom angegeben
Benutzerkonto blockiert}
\apiErrorNew{blocking-already}{402}{Benutzerkonto wird durch
das eigene Benutzerkonto blockiert}
\apiErrorNew{not-blocking}{403}{Benutzerkonto wird nicht durch
das eigene Benutzerkonto blockiert}
\apiErrorNew{no-user-invited}{410}{Kein Benutzerkonto eingeladen,
das nicht das eigene ist}
\apiErrorNew{user-already-in-group}{411}{Mindestens eine Identifikationsnummer
gehört zu einem Benutzerkonto, welches bereits Teil der Gruppe ist}
\apiErrorNew{user-not-in-group}{412}{Mindestens eine Identifikationsnummer
gehört zu einem Benutzerkonto, welches nicht Teil der Gruppe ist}
\apiErrorNew{already-participating-event}{420}{Das Benutzerkonto ist bereits
Teil dieser Verabredung}
\apiErrorNew{not-participating-event}{421}{Das Benutzerkonto ist kein Teil
dieser Verabredung}
\apiErrorNew{already-voting-for-option}{430}{Das Benutzerkonto hat bereits
eine Stimme für diese Option abgegeben}
\apiErrorNew{poll-not-multichoice}{431}{Es ist keine Mehrfachauswahl für
diese Abstimmung möglich}
\apiErrorNew{not-voting-for-option}{432}{Das Benutzerkonto hat keine Stimme
für dies Option abgegeben}

Bis auf dem \textbf{login}-Befehl und den \textbf{register}-Befehl erfordert
jeder Befehl folgenden Parameter:\\
\apiArgument{token/Authentifizierungtoken{,} welches beim Anmelden in das
Benutzerkonto vom Server zurückgegeben wurde}
\par\par Ist das übermittelte Token ungültig, wird der Befehl nicht
ausgeführt und folgender Fehlercode zurückgegeben:\\
\apiErrorPrint{token-invalid}

\apiCommand{register}
{Registrieren eines Nutzerkontos}
{user/Benutzername des Kontos,
pass/Passwort des Kontos,
email/Email des Kontos}
{token/Authentifizierungstoken{,} welches in weiteren Befehlen
als Eingabe verlangt wird}
{username-already-in-use,invalid-email}

\apiCommand{login}
{Anmelden in ein Nutzerkonto}
{user/Benutzername des Kontos,
pass/Passwort des Kontos}
{token/Authentifizierungstoken{,} welches in weiteren Befehlen
als Eingabe verlangt wird}
{cred-wrong}

\apiCommand{request-updates}
{Anfragen der Updateliste vom Server}
{user/Benutzername des Kontos}
{updates/} %TODO In welcher Form werden die Updates übergeben
{user-id-invalid}

\apiCommand{edit-username}
{Editieren des eigenen Benutzernamens}
{id/Identifikationsnummer des eigenen Benutzerkontos,
pass/Passwort des eigenen Kontos,
name/vorgeschlagener{,} neuer Name}
{---/Leeres JSON-Objekt bei Erfolg}
{cred-wrong, user-id-invalid, username-already-in-use}

\apiCommand{edit-email}
{Editieren der eigenen E-Mail-Adresse}
{id/Identifikationsnummer des eigenen Benutzerkontos,
pass/Passwort des eigenen Kontos,
email/vorgeschlagene{,} neue E-Mail}
{---/Leeres JSON-Objekt bei Erfolg}
{cred-wrong, user-id-invalid, invalid-email}\

\apiCommand{edit-password}
{Editieren des eigenen Passworts}
{id/Identifikationsnummer des eigenen Benutzerkontos,
pass/aktuelles Passwort des eigenen Kontos,
newpass/vorgeschlagenes{,} neues Passwort}
{---/Leeres JSON-Objekt bei Erfolg}
{cred-wrong, user-id-invalid}

\apiCommand{reset-password}
{Zurücksetzen des eigenen Passworts. Dies führt dazu, dass das eigene Passwort
vom Server durch ein von diesem generierten ersetzt wird. Anschließend wird das
neue Passwort an an die angegebene E-Mail-Adresse des Kontos verschickt.}
%TODO wirklich ersetzt oder ist das alte ebenfalls nach wie vor gültig
{id/Identifikationsnummer des eigenen Benutzerkontos,
pass/Passwort des eigenen Kontos}
{---/Leeres JSON-Objekt bei Erfolg}
{cred-wrong, user-id-invalid}

\apiCommand{delete-account}
{Löschen des eigenen Kontos. Dies führt wie erwartet dazu{,}
dass der Nutzer automatisch ausgeloggt wird und dadurch seinen
Authentifizierungstoken und somit den weiteren Zugriff auf die Funktionalitäten
der App verliert.}
{id/Identifikationsnummer des eigenen Benutzerkontos,
pass/Passwort des eigenen Kontos}
{---/Leeres JSON-Objekt bei Erfolg}
{cred-wrong, user-id-invalid}

\apiCommand{get-user-id}
{Abrufen der Idenfikationsnummer eines anderen Benutzekontos durch Übergeben
des Benutzernamens}
{user/Benutzername des Benutzerkontos}
{\dots/Eine Beschreibung eines Benutzerkontos{,} das zu dem angegebenen
Benutzernamen gehört (siehe \ref{sec:accountdesc})}
{username-invalid}

\apiCommand{add-contact}
{Hinzufügen eines anderen Benutzerkontos zur eigenen Kontaktliste.
Fügt ebenfalls das eigene Benutzerkonto zur Kontaktliste des anderen
Benutzerkontos hinzu.
Dies schlägt fehl, wenn eines der zwei Benutzerkonten das andere blockiert.}
{id/Identifikationsnummer des anderen Benutzerkontos}
{---/Leeres JSON-Objekt bei Erfolg}
{user-id-invalid,being-blocked,blocking-already}

\apiCommand{remove-contact}
{Entfernen eines anderen Benutzerkontos von der eigenen Kontaktliste.
Entfernt ebenfalls das eigene Benutzerkonto von der Kontaktliste des anderen.}
{id/Identifikationsnummer des anderen Benutzerkontos}
{---/Leeres JSON-Objekt bei Erfolg}
{user-id-invalid,not-in-contacts}

\apiCommand{list-contacts}
{Auflisten aller Kontakte des Benutzerkonto}
{---/Keine weiteren Parameter}
{contacts/Ein Array von Indetifikationsnummern anderer Benutzerkonten}
{user-id-invalid}

\apiCommand{block-account}
{Blockiert das angegebene Benutzerkonto.
Bis dies aufgehoben wird, können das eigene und das angegebene
Benutzerkonto sich nicht gegenseitig zur ihrer Kontaktliste hinzufügen.
Sind die beiden Benutzerkonten bereits Kontakte, werden diese vorher aus der
Kontaktliste des jeweils anderen Benutzerkontos entfernt.}
{id/Identifikationsnummer des anderen Benutzerkontos}
{---/Leeres JSON-Objekt bei Erfolg}
{user-id-invalid,blocking-already}

\apiCommand{unblock-account}
{Hebt die Blockierung des angegebenen Benutzerkontos durch das eigene
Benutzerkonto auf.}
{id/Identifikationsnummer des anderen Benutzerkontos}
{---/Leeres JSON-Objekt bei Erfolg}
{user-id-invalid,not-blocking}

\apiCommand{create-group}
{Erstellen einer Gruppe}
{name/Name der Gruppe,
members/Array an Identifikationsnummern aller Benutzerkonten{,} die nach
Erstellung der Gruppe dieser hinzugefügt werden sollen.
Die Identifikationsnummer des eigenen Benutzerkontos muss nicht angegeben
werden.
Falls dennoch vorhanden{,} wird diese ignoriert.
Das Array muss mindestens eine gültige Identifikationsnummer beinhalten{,} die
nicht die eigene ist.}
{id/Eindeutige Identifikationsnummer der Gruppe{,} mit der diese in
weiteren Befehlen referenziert werden kann}
{user-id-invalid,no-user-invited}

\apiCommand{edit-group-name}
{Editieren des Namens einer Gruppe, in der das Benutzerkonto Mitglied ist}
{id/Eindeutige Identifikationsnummer der Gruppe,
name/Neuer name der Gruppe}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,no-permission-group-edit}

\apiCommand{add-group-members}
{Hinzufügen eines oder mehrerer Benutzerkonten zu einer Gruppe, in der das
Benutzerkonto Mitglied ist}
{id/Eindeutige Identifikationsnummer der Gruppe,
members/Array an Identifikationsnummern aller Benutzerkonten{,} die der Gruppe
hinzugefügt werden sollen.
Es dürfen keine Identifikationsnummern von Benutzerkonten angegeben werden{,}
die bereits Teil der Gruppe ist.
Insbesondere darf nicht die Identifikationsnummer des eigenen Benutzerkontos
angegeben werden.}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,user-id-invalid,no-permission-members-edit,%
user-already-in-group}

\apiCommand{remove-group-members}
{Entfernen eines oder mehrerer Benutzerkonten von einer Gruppe, in der das
Benutzerkonto Mitglied ist}
{id/Eindeutige Identifikationsnummer der Gruppe,
members/Array an Identifikationsnummern aller Benutzerkonten{,} die aus der
Gruppe entfernt werden sollen.
Es dürfen keine Identifikationsnummern von Benutzerkonten angegeben werden{,}
die nicht Teil der Gruppe sind.
Es darf die Identifikationsnummer des eigenen Benutzerkontos angegeben werden.
Dies führt wie erwartet dazu{,} dass das eigene Benutzerkonto den weiteren
Zugriff auf die Gruppe verliert.
Werden durch diesen Befehl alle Mitglieder einer Gruppe entfernt{,} wird die
Gruppe gelöscht.}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,user-id-invalid,no-permission-members-edit,user-not-in-group}

\apiCommand{get-permissions}
{Abfragen der Rechte eines Benutzerkontos in einer Gruppe}
{id/Eindeutige Identifikationsnummer der Gruppe,
userid/Eindeutige Identifikationsnummer des Benutzerkontos}
{permissions/Ein Array an Booleans das die Berechtigungen darstellt}
{group-id-invalid}

\apiCommand{edit-permissions}
{Ändern der Rechte eines Benutzerkontos in einer Gruppe}
{id/Eindeutige Identifikationsnummer der Gruppe,
userid/Eindeutige Identifikationsnummer des Benutzerkontos,
permissions/Ein Array an Booleans das die Berectigungen darstellt}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid, no-permission-permissions-edit}

\apiCommand{create-event}
{Erstellen einer Verabredung in einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
werden soll,
title/Titel der Verabredung,
time-start/Startzeitpunkt (Angabe in Unixzeit%
\footnote{Siehe \enquote{Unixzeit}, Version 172239469, Wikipedia,\\
\url{https://de.wikipedia.org/w/index.php?title=Unixzeit&oldid=172239469}}),
time-end/Endzeitpunkt (Angabe in Unixzeit),
latitude/Breitengrad{,} auf dem die Verabredung stattfindet (Angabe als
Dezimalgrad),
longitude/Längengrad{,} auf dem die Verabredung stattfindet (Angabe als
Dezimalgrad)}
{id/Eindeutige Identifikationsnummer der Verabredung{,} mit der diese in
weiteren Befehlen referenziert werden kann}
{group-id-invalid,time-end-in-past,time-end-start-conflict,
no-permission-event-create}

\apiCommand{edit-event}
{Editieren einer Verabredung in einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde,
id/Identifikationsnummer der Verabredung,
\dots/Alle Eigenschaften{,} mit Ausnahme des Teilnehmerarrays und der
Identifikationsnummer{,} die überschrieben werden sollen.
Die Schlüssel entsprechen denen einer ausführlichen Verabredungsbeschreibung.}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,time-end-in-past,time-end-start-conflict,event-id-invalid,
no-permission-event-edit}

\apiCommand{join-event}
{Beitreten einer Verabredung einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde,
id/Identifikationsnummer der Verabredung}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,event-id-invalid,already-participating-event}

\apiCommand{leave-event}
{Verlassen einer Verabredung, an welcher das Benutzerkonto teilnimmt}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde,
id/Identifikationsnummer der Verabredung}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,event-id-invalid,not-participating-event}

\apiCommand{remove-event}
{Entfernen einer Verabredung aus einer Gruppe, in der das Benutzerkonto
Mitglied ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde,
id/Identifikationsnummer der Verabredung}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,event-id-invalid,no-permission-event-edit}

\apiCommand{create-poll}
{Erstellen einer Abstimmung in einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
werden soll,
question/Frage{,} über dessen Antwort abgestimmt wird,
multi-choice/Boolscher Wert{,} der angibt{,} ob ein Nutzer für mehrere
Optionen stimmen kann,
options/Array an Beschreibungen von Abstimmungsoptionen{,} die nach der
Erstellung der Abstimmung hinzugefügt werden sollen}
{id/Eindeutige Identifikationsnummer der Abstimmung{,} mit der diese in
weiteren Befehlen referenziert werden kann,
option-ids/Array an Identifikationsnummern der Abstimmungsoptionen. Die
Reihenfolge dieser IDs entspricht genau der Reihenfolge der angegebenen
Abstimmungsoptionen.}
{group-id-invalid,time-end-in-past,time-end-start-conflict,
no-permission-poll-create}

\apiCommand{edit-poll}
{Editieren einer Abstimmung in einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde,
id/Identifikationsnummer der Abstimmung,
\dots/Alle Eigenschaften{,} mit Ausnahme des Abstimmungsoptionsarrays und der
Identifikationsnummer{,} die überschrieben werden sollen.
Die Schlüssel entsprechen denen einer ausführlichen Abstimmungsbeschreibung.}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,poll-id-invalid,no-permission-poll-edit}

\apiCommand{add-poll-option}
{Hinzufügen einer Abstimmungsoption in einer Gruppe, in der das Benutzerkonto
Mitglied ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
wurde,
poll-id/Identifikationsnummer der Abstimmung{,} zu der die Abstimmungsoption
hinzugefügt werden soll,
latitude/Breitengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
longitude/Längengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
time-start/Vorgeschlagener Startzeitpunkt (Angabe in Unixzeit),
time-end/Vorgeschlagener Endzeitpunkt (Angabe in Unixzeit)}
{id/Eindeutige Identifikationsnummer der Abstimmungsoption{,} mit der diese in
weiteren Befehlen referenziert werden kann}
{group-id-invalid,poll-id-invalid,time-end-in-past,time-end-start-conflict,
no-permission-poll-edit}

% TODO: „Wählerarray“ besser formulieren
\apiCommand{edit-poll-option}
{Editieren einer Abstimmungsoption in einer Gruppe, in der das Benutzerkonto
Mitglied ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
wurde,
poll-id/Identifikationsnummer der Abstimmung,
id/Identifikationsnummer der Abstimmungsoption,
\dots/Alle Eigenschaften{,} mit Ausnahme des Wählerarrays und der
Identifikationsnummer{,} die überschrieben werden sollen.
Die Schlüssel entsprechen denen einer ausführlichen Abstimmungsbeschreibung.}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,poll-id-invalid,poll-option-id-invalid,no-permission-poll-edit}

\apiCommand{vote-for-option}
{Stimmen für eine Abstimmungsoption in einer Abstimmung einer Gruppe,
in der das Benutzerkonto Mitglied ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
wurde,
poll-id/Identifikationsnummer der Abstimmung,
id/Identifikationsnummer der Abstimmungsoption}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,poll-id-invalid,poll-option-id-invalid,poll-not-multichoice,
already-voting-for-option}

\apiCommand{withdraw-vote-for-option}
{Stimme zurückziehen für eine Abstimmungsoption in einer Abstimmung
einer Gruppe, in der das Benutzerkonto Mitglied ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
wurde,
poll-id/Identifikationsnummer der Abstimmung,
id/Identifikationsnummer der Abstimmungsoption}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,poll-id-invalid,poll-option-id-invalid,not-voting-for-option}

\apiCommand{remove-poll-option}
{Entfernen einer Abstimmungsoption in einer Gruppe, in der das Benutzerkonto
Mitglied ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
wurde,
poll-id/Identifikationsnummer der Abstimmung,
id/Identifikationsnummer der Abstimmungsoption}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,poll-id-invalid,group-id-invalid,poll-id-invalid,
poll-option-id-invalid,no-permission-poll-edit}

\apiCommand{remove-poll}
{Entfernen einer Abstimmung aus einer Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde,
id/Identifikationsnummer der Abstimmung}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid,poll-id-invalid,no-permission-poll-edit}

\apiCommand{send-chat-message}
{Senden einer Textnachricht an eine Gruppe, in der das Benutzerkonto Mitglied
ist}
{group-id/Identifikationsnummer der Gruppe,
message/Textnachricht} % TODO: Länge beschränken (vllt. auch Gruppengröße etc)
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid}

\apiCommand{list-groups}
{Auflisten der Gruppen, in denen das Benutzerkonto Mitglied ist}
{---/Keine weiteren Parameter}
{groups/Ein Array an oberflächlich beschriebenen Gruppen (siehe
Kapitel \ref{sec:groupdesc})}
{}

\apiCommand{get-group-details}
{Abrufen von Details einer Gruppe, in denen das Benutzerkonto Mitglied ist}
{id/Identifikationsnummer der Gruppe}
{\dots/Eine ausführliche Beschreibung der Gruppe{,} die zu der angegebenen
Identifikationsnummer gehört (siehe \ref{sec:groupdesc})}
{group-id-invalid}

\apiCommand{get-user-details}
{Abrufen von Details eines Benutzerkontos}
{id/Identifikationsnummer des Benutzerkontos}
{\dots/Eine Beschreibung eines Benutzerkontos{,} das zu der angegebenen
ID gehört (siehe \ref{sec:accountdesc})}
{user-id-invalid}

% TODO: Definiere „aktive Verabredung“
\apiCommand{get-event-details}
{Abrufen von Details einer aktiven Verabredung, die in einer Gruppe erstellt
wurde, in der das Benutzerkonto Mitglied ist}
{id/Identifikationsnummer der Verabredung,
group-id/Identifikationsnummer der Gruppe{,} in der die Verabredung erstellt
wurde}
{\dots/Eine ausführliche Beschreibung der Verabredung{,} die zu der angegebenen
Identifikationsnummer gehört (siehe \ref{sec:eventdesc})}
{group-id-invalid,event-id-invalid}

\apiCommand{get-poll-details}
{Abrufen von Details einer aktiven Abstimmung, die in einer Gruppe erstellt
wurde, in der das Benutzerkonto Mitglied ist}
{id/Identifikationsnummer der Abstimmung,
group-id/Identifikationsnummer der Gruppe{,} in der die Abstimmung erstellt
wurde}
{\dots/Eine ausführliche Beschreibung der Abstimmung{,} die zu der angegebenen
Identifikationsnummer gehört (siehe \ref{sec:polldesc})}
{group-id-invalid,poll-id-invalid}

% TODO: Zeit-Toleranz / Annahmen über Synchronität weiter oben spezifizieren
\apiCommand{request-position}
{Sendet eine Standortanfrage an eine Gruppe}
{id/Eindeutige Identifikationsnummer der Gruppe,
time/ Endzeit der Standortübertragung}
{---/Leeres JSON-Objekt bei Erfolg}
{group-id-invalid}

% TODO: Zeit-Toleranz / Annahmen über Synchronität weiter oben spezifizieren
\apiCommand{update-position}
{Aktualisiert die Position des Benutzerkontos.
Der Messzeitpunkt darf aus Sicht der Servers maximal 30 Sekunden in der Zukunft
liegen.}
{latitude/Breitengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
longitude/Längengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
time-measured/Zeitpunkt{,} zu dem die Position gemessen wurde (Angabe in
Unixzeit)}
{---/Leeres JSON-Objekt bei Erfolg}
{time-measured-future}

\subsection{Fehlercodes}\label{sec:errorcodes}
\apiErrorTable

\subsection{Gruppenbeschreibung}\label{sec:groupdesc}

\subsubsection{Oberflächlich}
\apiArgument{
    type/\enquote{group},
    id/Eindeutige Identifikationsnummer der Gruppe{,} mit der diese in
    weiteren Befehlen referenziert werden kann,
    checksum/Prüfsumme der ausführlichen Beschreibung (siehe
    \ref{sec:checksum})}

\subsubsection{Ausführlich}
\apiArgument{
    type/\enquote{group},
    id/Eindeutige Identifikationsnummer der Gruppe{,} mit der diese in
    weiteren Befehlen referenziert werden kann,
    name/Name der Gruppe,
    members/Array an Identifikationsnummern aller Benutzerkonten{,} die
    Mitglied der Gruppe sind,
    events/Array an oberflächlich beschriebenen Verabredungen{,} die in der
    Gruppe erstellt worden sind (siehe \ref{sec:eventdesc}),
    polls/Array an oberflächlich beschriebenen Abstimmungen{,} die in der
    Gruppe erstellt worden sind (siehe \ref{sec:polldesc})
}

\subsection{Benutzerkontobeschreibung}\label{sec:accountdesc}
\apiArgument{type/\enquote{account},
    id/Eindeutige Identifikationsnummer des Benutzerkontos{,} mit der
    dieses in weiteren Befehlen referenziert werden kann,
    user/Benutzername des Kontos
}

\subsection{Verabredungsbeschreibung}\label{sec:eventdesc}

\subsubsection{Oberflächlich}
\apiArgument{type/\enquote{event},
    id/Eindeutige Identifikationsnummer der Verabredung{,} mit der
    diese in weiteren Befehlen referenziert werden kann,
    checksum/Prüfsumme der ausführlichen Beschreibung (siehe
    \ref{sec:checksum})
}

\subsubsection{Ausführlich}
\apiArgument{type/\enquote{event},
    id/Eindeutige Identifikationsnummer der Verabredung{,} mit der
    diese in weiteren Befehlen referenziert werden kann,
    title/Titel der Verabredung,
    creator/Nutzername des Benutzerkontos{,} mit dem die Verabredung erstellt
    wurde,
    time-start/Startzeitpunkt,
    time-end/Endzeitpunkt,
    latitude/Breitengrad{,} auf dem die Verabredung stattfindet
    (Gleitkommazahl),
    longitude/Längengrad{,} auf dem die Verabredung stattfindet
    (Gleitkommazahl),
    participants/Array an Identifikationsnummern der Benutzerkonten{,} die an
    der Verabredung teilnehmen
}

\subsection{Abstimmungsbeschreibung}\label{sec:polldesc}
% TODO: Split in oberflächlich und ausführlich
\apiArgument{
    type/\enquote{poll},
    id/Eindeutige Identifikationsnummer der Abstimmung{,} mit der diese in
    weiteren Befehlen referenziert werden kann,
    question/Frage{,} über dessen Antwort abgestimmt wird,
    multi-choice/Boolscher Wert{,} der angibt{,} ob ein Nutzer für mehrere
    Optionen stimmen kann,
    options/Array an Beschreibungen von Abstimmungsoptionen{,} die Teil dieser
    Abstimmung sind
}

\subsection{Abstimmungsoptionsbeschreibung}\label{sec:polloptiondesc}
\apiArgument{
    type/\enquote{poll-option},
    id/Eindeutige Identifikationsnummer der Abstimmungsoption{,} mit der diese
    in weiteren Befehlen referenziert werden kann,
    latitude/Breitengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
    longitude/Längengrad der vorgeschlagenen Position (Angabe als Dezimalgrad),
    time-start/Vorgeschlagener Startzeitpunkt (Angabe in Unixzeit),
    time-end/Vorgeschlagener Endzeitpunkt (Angabe in Unixzeit),
    supporters/Array an Identifikationsnummern der Benutzerkonten{,} die
    momentan für diese Options stimmen.
}

\subsection{Prüfsummen für ausführliche Beschreibungen}\label{sec:checksum}
\newcommand{\hashAlg}{MD5}
Um unnötige ausführliche Übertragungen zu vermeiden beinhalten oberflächliche
Beschreibungen Prüfsummen der zum selben Objekt gehörenden ausführlichen
Beschreibung.
Der Klient ist somit in der Lage, festzustellen, ob seine lokalen Datensätze
mit denen des Servers übereinstimmen, ohne die Datensätze erneut anfordern zu
müssen.

\par Zur Berechnung der Prüfsummen wird der \hashAlg-Algorithmus verwendet.

\par Als Grundlage der Eingabe an den \hashAlg-Algorithmus wird die
ausführliche Beschreibung des jeweiligen Objektes im gleichen Format wie in den
vorangegangenen Kapiteln verwendet.

\par Da es aufgrund von Umordnungen, Leerzeichen, Zeilenumbrüchen etc. mehrere
unterschiedliche, aber äquivalente JSON-Darstellungen für eine ausführliche
Beschreibung gibt, müssen diese vor Eingabe an den \hashAlg-Algorithmus in eine
normalisierte Form gebracht werden:

\par \textit{Hinweis: In dem folgenden Absatz bezeichnen Ziffern nicht etwa die
ASCII-Ziffern \enquote{0} bis \enquote{9} mit den Werten 48 bis 57, sondern die
nicht darstellbaren Steuerzeichen mit den Werten 0 bis 9.}\\
JSON-Objekte werden mit einer 1 begonnen und mit einer 3 beendet.
Eigenschaften dieser JSON-Objekte werden mit einer 2 statt einem Komma
getrennt.
Die Eigenschaften werden gemäß der in den Beschreibungsspezifikationen
aufgeführten Reihenfolgen sortiert.
JSON-Arrays werden mit einer 4 begonnen und mit einer 6 beendet.
Elemente dieser JSON-Arrays werden mit einer 5 statt mit einem Komma getrennt.
In JSON-Arrays von Beschreibungen kommen entweder nur Beschreibungen anderer
Objekte oder nur Integer vor.
Diese werden aufsteigend nach ihren IDs bzw. aufsteigend nach ihrem Wert
sortiert.

Alle JSON-Objekteigenschaften werden ohne Schlüssel, Doppelpunkte, geschwungene
Klammern und zusätzliche Leerzeichen oder Zeilenumbrüche konkateniert.
Alle JSON-Arrayelemente werden ohne eckige Klammern und zusätzliche
Leerzeichen oder Zeilenumbrüche konkateniert.
Die doppelten Anführungszeichen um Zeichenketten werden entfernt.
Da alle sechs Trennzeichen nur als Escape-Sequenzen, nicht aber direkt im
JSON-Format vorkommen können\footnote{Vgl. \enquote{RFC 7159}, Kapitel 7
\enquote{Strings}, \url{https://tools.ietf.org/html/rfc7159}} ist diese
Darstellung eindeutig.

% TODO: Update example
\par Im folgenden beispielhaft eine Verabredung mit folgenden Details:
\begin{itemize}
    \item Besitzt die ID 12
    \item Trägt den Titel \enquote{Beispielverabredung 1010}
    \item Erstellt vom Benutzerkonto mit ID 200
    \item Beginnt am 01. Januar 2018 um 00:00:00.000
    \item Endet am 03. Januar 2018 um 18:30:00.000
    \item Findet auf der Position 49.011978 N, 8.416377 E statt
    \item Die Benutzerkonten mit den IDs 200, 3 und 43378 sind als Teilnehmer
        eingetragen
\end{itemize}

Eine mögliche Kodierung der ausführlichen Beschreibung im JSON-Format kann wie
folgt aussehen:
\begin{lstlisting}[language=json,firstnumber=1]
{   "type" : "event",
    "id": 2,
    "title": "Beispielverabredung 1010",
    "creator": 200,
    "time-start": 1514761200000,
    "time-end": 1515000600000,
    "latitude": 49.011978,
    "longitude": 8.416377,
    "participants": [ 3, 200, 43378 ]
}
\end{lstlisting}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=1pt] (char) {\scriptsize #1};}}

Die normalisierte Darstellung dieser Verabredung sieht wie folgt aus.
Die Steuerzeichen werden durch \circled{1}, \circled{2}, \circled{3} etc.
dargestellt.\\
\textit{Hinweis: Die Zeilenumbrüche dienen nur der besseren Lesbarkeit und sind
nicht in der normalisierten Darstellung enthalten.}

\begin{lstlisting}[language=norm,firstnumber=1]
(*\circled{1}*)"event"(*\circled{2}*)2(*\circled{2}%
*)"Beispielverabredung 1010"(*\circled{2}*)200(*\circled{2}*)1514761200000(*%
\circled{2}*)
1515000600000(*\circled{2}*)49.011978(*\circled{2}*)8.416377(*\circled{2}%
\circled{4}*)3(*\circled{5}*)200(*\circled{5}*)43378(*\circled{6}\circled{3}*)
\end{lstlisting}

\par Ein beispielhafter Algorithmus für die Normalisierung ist im folgenden
als Python-Implementierung angegeben:

\pythonexternal{scripts/normalize.py}

\subsection{Abrufen von Aktualisierungen}\label{sec:get-updates}
Zum Abrufen von Aktualisierungen gibt es mehrere Möglichkeiten.

\begin{itemize}
    \item Eine einzelne Anfrage an den Server, die alle aktuell für das eigene
        Benutzerkonto vorliegenden Änderungen abruft
    \item Eine Anfrage an den Server, die die aktuelle Verbindung als
        \enquote{Aktualisierungsverbindung} kennzeichnet.
        Auf einer Aktualisierungsverbindung werden alle Befehle des Klienten
        ignoriert.
        Erhält der Server für ein Benutzerkonto, welches eine offene
        Aktualisierungsverbindung zum Server hat, eine Aktualisierung, wird
        diese sofort über die Aktualisierungsverbindung an den Klienten
        gesendet.
    \item Push-Notifications.
        Diese Möglichkeit der Übertragung ist auf mehreren
        Smartphone-Betriebssystemen vertreten und erlaubt sehr
        ressourceneffiziente Mitteilungen an den Klienten.
        Für das verwendete Framework gibt es neben Google's Firebase noch
        wenige weitere quelloffene Kandidaten.
        Die Umsetzung dieser Übertragungsmöglichkeit wird sich erst während
        der Implementierung zeigen.
\end{itemize}


\end{document}
