\documentclass[parskip=full,11pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[useregional]{datetime2}
\usepackage[pdfborderstyle={/S/U/W 0}]{hyperref}
\usepackage[nameinlink]{cleveref}
\usepackage[section]{placeins}
\usepackage[top=2.5cm, bottom=2.5cm, left=4cm, right=3cm]{geometry}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{csquotes}
\usepackage{amsmath} % for $\text{}$
\usepackage{changelog} % local .sty file
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\setlist{nosep}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}{\text{#2}}$}
\raggedbottom
\crefname{figure}{Abb}{Abb}

\newcommand\producttitle{treff.}
\newcommand\protocolversion{0.3}
\hypersetup{
	pdftitle={\producttitle~- Änderungsdokument},
	bookmarks=true,
}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{%
    \ifstr{#1}{subsubsection}{%
        \makebox[0pt][r]{#4}%
    }{%
        \makebox[0pt][r]{#3}#4%
    }%
}%

% header & footer
\usepackage{scrlayer-scrpage}
%\lofoot{\today}
%\refoot{\today}
\pagestyle{scrheadings}
%\let\raggedsection\centering

\title{\includegraphics[width = 80mm]{images/logo_crop.png}}
\subtitle{\huge Änderungsdokument}
\author{Lukas Dippon
        \and Jens Kienle
        \and Matthias Noll
        \and Fabian Röpke
        \and Tim Schmidt
        \and Simon Vögele}

\begin{document}

\maketitle
\thispagestyle{empty} % removed page number from title

\pagebreak
\tableofcontents

%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Entwurf}



%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Server}



%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Klient}

\subsection{TreffPunkt}
Für einzelne Daten von primitiven Datentypen bietet es sich an, diese in
Shared-Preferences zu speichern. Allerdings wird ein Context benötigt, um auf
diese zuzugreifen. Um Klassen, welche keinen eigenen Context besitzen, trotzdem
den Zugriff auf Shared-Preferences zu ermöglichen, wurde die TreffPunkt Klasse
als Superklasse für Application eingeführt. Sie bietet statisch einen Context,
welcher nicht von irgendwelchen Lebenszyklen abhängig ist.\\
Dieser ermöglicht es auch, auf String Ressourcen zuzugreifen, in unserem Fall
zum Beispiel Errorcodes in mehreren Sprachen zur Verfügung zu stellen und diese
Contextunabhängig zu verwenden.

\subsection{Befehle}
Die interne Umsetzung der Netzwerkbefehle wurde um das Commands Package
erweitert. Nach dem Command Design Pattern werden nun die einzelnen Server
Befehle durch Objekte repräsentiert. Die Hauptfunktion der neuen Klassen
besteht zum einen darin, Objekte für die JSON Serialisierung zu verwalten. Zum
anderen werden von dort aus aber auch die lokalen Datenbankzugriffe (und
andere Reaktionen auf Antworten des Servers) gesteuert. So wird vermieden, dass
die ViewModels auf Reaktionen des Servers warten müssen und die UI einfriert.
Um eine zu enge Kopplung zu verhindern, wird die Ausführung eines Befehls
weiterhin die jeweilige Methode des RequestEncoders veranlasst\\
Zudem gibt es ein weiteres Package, welches die im Protokoll beschriebenen
Entitäten enthält. Dieses ist nötig, um eine gewisse Konsistenz zwischen Server
und Klient zu schaffen.\\
Für die bereits angesprochene JSON Serialisierung wird sowohl Server- , als
auch Klientseitig die Jackson Library verwendet.

\subsection{Karte}
osmdroid bonuspack hinzugefügt, um clustering zu verwirklichen
marker package im map package: UserMarker, EventMarker, +...

\subsection{Datenbank}
Events enthalten nun die eindeutige Identifikationsnummer der Gruppe,
zu der sie gehören. So müssen Events nicht innerhalb der Gruppe
gespeichert oder referenziert werden und können leichter in der
Datenbank gefunden werden.\\
User Entitäten haben nun weitere Felder, die angeben, ob der aktuelle Benutzer
mit ihnen befreundet ist, sie blockiert hat, eine Freundschaftsanfrage
gesendet oder bekommen hat.\\
Außerdem wurde die eigene Position Entität durch android.location.Location
ersetzt und der TypeConverter angepasst. Diese Klasse speichert bereits
einen Zeitpunkt und macht so das Speichern des Zeitpunktes des letzten
Positionsupdates überflüssig.

\subsection{Ortung}
GPSProvider nur Service, Map ist selbst auch LocationListener
GPSProviderManager hinzugefügt, um den GPSProvider zu starten

\subsection{Gruppeneinstellungen}
Der Einstellungsbildschirm der Gruppe ist nun eine Activity statt einem
Fragment, sodass die Historie der vergangenen Bildschirme und die
Navigation einfacher und sinnvoller umgesetzt werden können.\\
Das zugehörige ViewModel wurde entfernt, stattdessen wird das
GroupViewModel verwendet, um Redundanz zu vermeiden.\\
Um die Gruppenmitglieder anzuzeigen, wurde ein MemberListAdapter
hinzugefügt.

\subsection{Über uns}
about package/activity hinzugefügt

\subsection{Login}
LoginFragment hinzufügt

\subsection{Dependency Injection}
AppModule Klasse entfernt (kein Dagger mehr für DI)
Repos keine Singletons, werden einmal in der ViewModelFactory erstellt

\subsection{ViewModels}
util package: ViewCall und State enum
Aufrufe im ViewModel, welche einen Context benötigen, werden in einem SingleLiveEvent State Objekt gespeichert, welches vom Context (Fragment/Activity) observed wird. Dieses kann dann entsprechend auf State-Änderungen reagieren.
ViewModels (nicht die Fragments) erweitern ItemClickListener um alle Nutzerinteraktionen im ViewModel zu behandeln
PagedListAdapter statt normalen Adaptern um unnötiges Laden von ListItems zu vermeiden

\subsection{NavigationDrawer}
TabbedNavigationActivity entfernt, nur noch NavigationActivity
NavigationDrawerFragment nur noch xml, kein Fragment


%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Protokoll}



\end{document}
